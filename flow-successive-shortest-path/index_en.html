<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta charset="utf-8">
    <meta name="description" content="This applet demonstrates the Successive Shortest Path algorithm to find a minmum cost flow" />
    <meta name="keywords" content="Successive Shortest Path, minimum cost flow, algorithm, TUM, Technische Universität München, Applet">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="author" content="Gergana Kratuncheva">
	
	
	<!--     the whole page layout style -->
    <link rel="stylesheet" type="text/css" href="../library/css/style.css" />

    <link rel="stylesheet" type="text/css" href="../library/css/tum-theme2/jquery-ui-1.10.1.custom.min.css" />
	
	
	 <!--     MathJax, used in the more tab in pseudocode -->
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            showMathMenu: false,
            showMathMenuMSIE: false
        });
    </script>
	
	
	<!-- LOCAL -->
    <script src="../library/js/jquery-1.9.1.min.js" type="text/javascript"></script>
    <script src="../library/js/jquery-ui-1.10.1.custom.min.js" type="text/javascript"></script>
    <link type="text/css" href="../library/css/mmenu/jquery.mmenu.all.css" rel="stylesheet" />
    <script type="text/javascript" src="../library/js/mmenu/jquery.mmenu.min.all.js"></script>
    <script type="text/javascript" src="../library/js/mathjax/MathJax.js?config=TeX-AMS-MML_SVG.js&locale=en"></script>
    <script src="../library/js/d3/d3.js"></script>
	
	
	<!--     Adrians d3 related library code -->
    <script src="../flow-successive-shortest-path/js/Graph.js"></script>
    <script src="../flow-successive-shortest-path/js/GraphDrawer.js"></script>
    <script src="../flow-successive-shortest-path/js/GraphEditor.js"></script>
    <script src="../flow-successive-shortest-path/js/Logger.js"></script>
    <script src="../flow-successive-shortest-path/js/Tab.js"></script>
    <script src="../flow-successive-shortest-path/js/AlgorithmTab.js"></script>
    <script src="../flow-successive-shortest-path/js/GraphEditorTab.js"></script>
    <script src="../flow-successive-shortest-path/js/siteAnimation.js"></script>
	
	 <!-- LNG -->
    <script src="../library/js/lang.js" type="text/javascript"></script>
    <script src="../library/js/utilities.js" type="text/javascript"></script>
	
	
	<!--Style-->
	<link rel="stylesheet" type="text/css" href="../flow-successive-shortest-path/css/graph-style.css" />
    <link rel="stylesheet" type="text/css" href="../flow-successive-shortest-path/css/style.css" />

	
	<!--     Files used only for this applet -->
    <script src="js/siteLayout.js" type="text/javascript"></script>
    <script src="js/flowSSPAlgorithm.js" type="text/javascript"></script>
	<script src="js/ExerciseTab1.js" ></script>
    <script src="js/Exercise1.js"></script>
	<script src="js/ExerciseTab2.js" ></script>
    <script src="js/Exercise2.js"></script>
	
	<!--Title-->
	<title>Successive Shortest Path Algorithm For Min-Cost-Flow </title>

</head>
	
<body>

<!-- svg definitons -->
    <svg xmlns="http://www.w3.org/2000/svg" version="1.1" xlink="http://www.w3.org/1999/xlink">
      <defs>
        <marker id="arrowhead2" refX="24" refY="4" markerWidth="24" markerHeight="8" orient="auto" markerUnits="userSpaceOnUse">
          <path d="M 0,0 V 8 L12,4 Z"></path>
        </marker>

         <marker id="arrowhead2-red" refX="24" refY="4" markerWidth="24" markerHeight="8" orient="auto" markerUnits="userSpaceOnUse" fill="rgb(196, 7, 27)">
          <path d="M 0,0 V 8 L12,4 Z"></path>
        </marker>

         <marker id="arrowhead2-lightRed" refX="24" refY="4" markerWidth="24" markerHeight="8" orient="auto" markerUnits="userSpaceOnUse" fill="rgb(240, 128, 128)">
          <path d="M 0,0 V 8 L12,4 Z"></path>
        </marker>

         <marker id="arrowhead2-green" refX="24" refY="4" markerWidth="24" markerHeight="8" orient="auto" markerUnits="userSpaceOnUse" fill="rgb(115, 183, 141)">
          <path d="M 0,0 V 8 L12,4 Z"></path>
        </marker>
      </defs>
    </svg>
    <noscript>
        <div class="ui-widget">
            <div class="ui-state-error ui-corner-all" style="padding: .7em;">
                <div class="ui-icon ui-icon-alert errorIcon"></div>
                <strong>Please activate Javascript!</strong>
                <ul style="margin: 0px;">
                    <li>
                        This website needs Javascript in order to be displayed properly.
                    </li>
                    <li>
                        Javascript is currently deactivated in your browser. A manual for the activation of Javascript can be found <a href="http://www.enable-javascript.com/">here</a>.
                    </li>
                </ul>
            </div>
        </div>
    </noscript>
    <script>
        $(function() {
            initializeSiteLayout(flowSSPAlgorithm);

        });
		<!--LNG.setLanguage('en');-->
        $(document).ready(function() {
            $("#menu").mmenu({
               "navbar": {
                  "title": "Übersicht"
               },
               "offCanvas": {
                  "zposition": "front"
               },
               "counters": true,
               "slidingSubmenus": true,
               "classes": "mm-light",
            });
         });
    </script>
    <a id="menu_link" href="#menu"></a>
    <nav id="menu">
        <ul>
            <li>
                <a style="white-space:pre-line" href="http://www-m9.ma.tum.de/Allgemeines/GraphAlgorithmenEn">
                <img src="../library/img/logo_ohne.png" alt="Overview Graph Algorithms">
                Graph Algorithms Landing Page</a>
            </li>
            <li><span>Shortest Path Algorithms</span>
                <ul>
                   <li><a href="../spp-dijkstra/index_en.html">Dijkstra's Algorithm</a></li>
                   <li><a href="../spp-a-star/index_en.html">A* Algorithm</a></li>
                   <li><a href="../spp-bellman-ford/index_en.html">Bellman-Ford Algorithm</a></li>
                   <li><a href="../spp-floyd-warshall/index_en.html">Floyd-Warshall Algorithm</a></li>
                   <!--<li><a href="../spprc-label-setting/index_en.html">Label-Setting Algorithm</a></li>-->
                </ul>
            </li>
            <li><span>Spanning Tree Algorithms</span>
                <ul>
                   <li><a href="../mst-prim/index_en.html">Prim's Algorithm</a></li>
                   <li><a href="../mst-kruskal/index_en.html">Kruskal's Algorithm</a></li>
                </ul>
            </li>
            <li><span>Flow Algorithms</span>
                <ul>
                   <li><a href="../flow-ford-fulkerson/index_en.html">Ford-Fulkerson Algorithm</a></li>
				   <!-- TODO: Add link for Dinic Algorithm when done-->
                   <li class="Selected"><a href="../flow-cycle-cancelling/index_en.html">Cycle-Cancelling Algorithm</a></li>
				   <li class="Selected"><a href="../flow-successive-shortest-path/index_en.html">Successive-Shortest-Path Algorithm</a></li>
                   <!--<li><a href="../flow-push-relabel/index_en.html">Push-Relabel Algorithm</a></li>-->
                </ul>
            </li>
            <li><span>Matching Algorithms</span>
                <ul>
                   <li><a href="../matchings-hopcroft-karp/index_en.html">Hopcroft-Karp Algorithm</a></li>
                   <li><a href="../matchings-hungarian-method/index_en.html">Hungarian Method</a></li>
                   <li><a href="../matchings-blossom-algorithm/index_en.html">Blossom Algorithm</a></li>
                </ul>
            </li>
            <li><span>Euler Tours and Chinese Postman Problem</span>
                <ul>
                   <li><a href="../hierholzer/index_en.html">Hierholzer's Algorithm</a></li>
                   <li><a href="../directed-chinese-postman/index_en.html">Chinese Postman Problem</a></li>
                </ul>
            </li>
        </ul>
    </nav>
    <!--<div>-->
    <header>
        <img src="img/title.svg" alt="A maximum flow"></img>
        <span class="adrianheader">Successive Shortest Path Algorithm</span>
        <img style="position:absolute; right:0px" src="../library/img/TUMLogo.png" alt="Technische Universität München">
    </header>

<!--     <svg height="0px" widht ="0px">
        <defs>
        <marker id="arrowhead2" refX="12" refY="2" markerWidth="12" markerHeight="4" orient="auto"><path d="M 0,0 V 4 L6,2 Z"></path></marker>
        </defs>
    </svg> -->
	
	
	<!-- Add tabs -->
	<div id="tabs">
        <ul>
		    <!-- Define the tabs -->
            <li><a href="#tab_te"><span>Introduction</span></a></li>
            <li><a href="#tab_tg"><span>Create a graph</span></a></li>
            <li><a href="#tab_ta"><span>Run the algorithm</span></a></li>
            <li><a href="#tab_ti"><span>Description of the algorithm</span></a></li>
            <li><a href="#tab_tf1"><span>Exercise 1</span></a></li>
            <li><a href="#tab_tf2"><span>Exercise 2</span></a></li> 
            <li><a href="#tab_tw"><span>More</span></a></li>
        </ul>
	
	
	
	
	
	 <!-- TAB Einführung -->
        <div id="tab_te">
            <div id="te_div_Einfuehrungstext">

                <div id="te_div_beispiel1Container">
                <div id="svgtest"></div>
                <img id="te_img_beispiel1" src="img/ahuja.svg" alt="ahuja">

                <p>What is the cheapest way to send 4 units of flow from s to t?</p>
				</div>
<!--                 <div id="te_div_beispiel1Container"><img id="te_img_beispiel1" src="https://i1.wp.com/cs.stanford.edu/people/trevisan/cs261-11/network1.png" alt="Flow problem in network routing capacity"><p>Flow problem in network routing capacity</p></div> -->

                <h1>The Min-Cost Flow Problem</h1>
                <p>Say we want to transport a certain amount of resources from point A to point B. The routes that can be used have limited <strong>capacities</strong> and sometimes also other properties (,say length, number of traffic lights, etc.) which we can summarize under the term <strong>cost</strong>. Of course, not all possible routes from A to B have the same cost. Sometimes the capacity of the cheapest route is smaller than the amount of resources we would like to transport, so we need to also use other routes.</p>

                <p>The problem of transporting a certain amount of resources with minimal costs is called the <strong>minimum-cost flow problem</strong>.</p>

                <h2>This applet presents the successive shortest path algorithm for solving the  minimum-cost flow problem on a given network.</h2>
                <div id ="te_div_Entscheidung">
                    <h2>What do you want to do first?</h2>
                    <button id="te_button_gotoDrawGraph">Test the algorithm!</button> 
					<button id="te_button_gotoIdee">Read detailed description of the algorithm</button>
                </div>
                <p></p>
                <br style="clear: both;" />
            </div>
        </div>

        <!-- TAB Graph Erstellen -->
        <div id="tab_tg">
            <div>
                <div class="canvasWrapper">
                    <div class="svgContainer">
                      <svg class="graphCanvas" id="tg_canvas_graph" width="700" height="500"></svg>
                      <a class="svgDownloader" download="graph-editor.svg" href="data:text/plain,test">Download Graph</a>
                    </div>
                    <div class="Legende" id="tg_div_Legende">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                        <div class="LegendeText">
                            <table>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/node.svg" alt="node" class="LegendeIcon"></td>
                                    <td><span>Node</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/edge.svg" alt="edge" class="LegendeIcon"></td>
                                    <td><span>Edge with capacity 10 and cost 1</span></td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <div class="LegendeMinimized">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    </div>
                </div>
                <div id="tg_div_statusWindow" class="statusWindow">
                    <h2>Which graph do you want to execute the algorithm on?</h2>
                    <h3>Start with an example graphs:</h3>
                    <label for="graphSelector">Select </label>
                    <select name="graphSelector" id="tg_select_GraphSelector">
                        <option selected = true label="graph 1">graph1</option>
                        <option label="graph 2">graph2</option>
						<option label="graph 3">graph3</option>
						<option label="graph 4">graph4</option>
						<option label="graph 5">graph5</option>
						<option label="graph 6">graph6</option>
						<option label="graph 7">graph7</option>
						<option label="graph 8">graph8</option>
						<option label="graph 9">graph9</option>
                    </select>


                    <h3>Modify it to your desire:<br></h3>
                    <div id="tg_div_statusErklaerung">
                    <ul>
                        <li>To create a node, double-click in the drawing area.</li>
                        <li>To create an edge, first click on the output node and then click on the destination node.</li>
                        <li>The edge cost and capacity can be changed by double clicking on the edge. Note that for this algorithm neither the capacities nor the costs of the edges can be negative!</li>
                        <li>Right-clicking deletes edges and nodes.</li>
                    </ul>
                    </div>

                    <h3>Download the modified graph:</h3>

                    <a id="fileDownloader" download="graph.txt" href="data:text/plain,test">Download</a>

                    <h3>Upload an existing graph:</h3>
                    <input type="file" id="fileUploader" accept=".txt"/></input> <!--name="files[]" accept="text/*"-->
                    <div id="ta_div_parseError" title="Error reading graph from file">
<!--                         <h2>Error code:</h2> -->
                        A
                        <h2 style="color:red" id="ta_div_parseErrorText"></h2>
                        occured when reading from file:
                        <h3 id="ta_div_parseErrorFilename"></h3>
                        the contents:
                        <pre id="ta_div_parseErrorDescription"></pre>
                    </div>

                    <h3>What next?</h3>
                   <p><button id="tg_button_gotoAlgorithmTab">Ready &ndash; Run the Algorithm!</button></p>


                </div>
            </div>
        </div>

        <!-- TAB Algorithmus ausführen -->
        <div id="tab_ta">
            <div>
                <div class="canvasWrapper">
                       <div class="svgContainer">
                        <svg class="graphCanvas" id="ta_canvas_graph" width="700" height="450"></svg>
						</div>
                        <a class="svgDownloader" download="graph-algo.svg" href="data:text/plain,test">Download Graph</a>
                    <div id="graph-info">
                        <span id="graph-state"></span>
                    </div>
                    <div id="cost-info">
                      <span id="currMinCost"></span>
                    </div>
                    <div class="Legende">
						<h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>

						<div class="LegendeText">
							<table>
								<tr>
									<td class="LegendeTabelle"><img src="img/node.svg" alt="node" class="LegendeIcon"></td>
									<td><span>node</span></td>
								</tr>
								<tr>
									<td class="LegendeTabelle"><img src="img/node-st.svg" alt="node" class="LegendeIcon"></td>
									<td><span>source/target node</span></td>
								</tr>
								<tr>
									<td class="LegendeTabelle"><img src="img/node-excess.svg" alt="node" class="LegendeIcon"></td>
									<td><span>excess node</span></td>
								</tr>
								<tr>
									<td class="LegendeTabelle"><img src="img/node-demand.svg" alt="node" class="LegendeIcon"></td>
									<td><span>demand node</span></td>
								</tr>
								<tr>
									<td class="LegendeTabelle"><img src="img/edge-flow.svg" alt="edge" class="LegendeIcon"></td>
									<td><span>edge with capacity 10, flow 7 and cost 1</span></td>
								</tr>
								<tr>
									<td class="LegendeTabelle"><img src="img/edge-residual.svg" alt="edge" class="LegendeIcon"></td>
									<td><span>edge in residual network</span></td>
								</tr>
								<tr>
									<td class="LegendeTabelle"><img src="img/edge-sp.svg" alt="edge" class="LegendeIcon"></td>
									<td><span>edge in shortest path</span></td>
								</tr>
							</table>
						</div>
					</div>
                    <div class="LegendeMinimized">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    </div>
                </div>
                <div id="ta_div_statusWindow" class="statusWindow">
                    <h2 class="">Algorithm status</h2>
                    <div id="ta_div_abspielbuttons"> <!--class="ui-widget-header ui-corner-all"-->
                        <input  id="ta_button_rewind" type="checkbox"><label for="ta_button_rewind" id="ta_button_text_rewind">rewind</label>

                        <button id="ta_button_Zurueck">prev</button>

                        <button id="ta_button_1Schritt">next</button>

                        <input  id="ta_button_vorspulen" type="checkbox"><label for="ta_button_vorspulen" id="ta_button_text_fastforward">fast forward</label>

                        <span id="ta_button_text_pause" style="display:none">pause</span>
                    </div>
                    
					<div id = "ta_div_statusTabs">
						<ul> 
							<li>
								<a href = "#ta_div_statusErklaerung">  Explanation
								</a>
							</li>
							<li>
								<a href = "#ta_div_statusPseudocode">  Pseudocode
								</a>
							</li>
							<li>
								<a href = "#ta_div_statusVariables">  Variables
								</a>
							</li>					
						</ul>
						<div id = "ta_div_statusErklaerung">
							<div id = "explanation-select-source">
								<h3> First choose a source node.</h3>
								<p> Please click on a node in the network to select it as the source/starting node <math xmlns="http://www.w3.org/1998/Math/MathML">
                                    <mstyle mathvariant="bold">
                                      <mi>s</mi>
                                    </mstyle>
                                  </math>. The flow is going to start from this node. It will have no incoming flow, but it will have outgoing flow (with the magnitude of the maximal feasible flow in the network) which makes it an excess node.
							</div>
							<div id = "explanation-select-target">
								<h3> Then choose a target node.</h3>
								<p> Please click on a node in the network to select it as the sink/target node <math xmlns="http://www.w3.org/1998/Math/MathML">
                                    <mstyle mathvariant="bold">
                                      <mi>t</mi>
                                    </mstyle>
                                  </math>. The flow ends in this node. It will have no outgoing flow, but it will still have incoming flow (with the magnitude of the maximal feasible flow in the network) which makes it a demand node.
							</div>
							 <div id="explanation-start-algorithm">
                                <h3>Successive Shortest Path algorithm</h3>
                                <p>Now the algorithm can begin. The maximal feasible flow in this graph is calculated with the help of the <a href = "https://www-m9.ma.tum.de/graph-algorithms/flow-ford-fulkerson/index_en.html"> Ford-Fulkerson algorithm</a>. The calculated flow is then set as an excess on the source node and as a demand on the target node: \(b(s) = max\ flow\) and \(b(t) = - max\ flow\).</p>
								<p>								Please click on <strong>next</strong> to start the algorithm.</p>
                            </div>
							<div id = "explanation-main-loop"> 
								<h3> Entering the main loop </h3>
								<p>When the algorithm has found the maximal flow and the excess and demand nodes with their corresponding values <math>
								  <mi>b</mi>
								  <mo stretchy="false">(</mo>
								  <mi>s</mi>
								  <mo stretchy="false">)</mo>
								  <mo>=</mo>
								</math>
							<tspan id="bs" class="algoInfoTD" style="color:green">-</tspan>
							 and 
							<math>
							  <mi>b</mi>
							  <mo stretchy="false">(</mo>
							  <mi>t</mi>
							  <mo stretchy="false">)</mo>
							  <mo>=</mo>
							</math>
							<tspan id="bt" class="algoInfoTD" style="color:red">-</tspan> it goes into the main loop.
							</p>
							<p>
							In the main loop the algorithm repeatedly tests for normalization with the condition \(\mathcal b(s) = 0 \). If the condition is satisfied the algorithm terminates. If node \(\mathcal s \) still has excess supply then the alorithm goes to the next step. </p>
							<p> In this step the algorithm also builds the residual network on which the fuhrther steps are going to be performed. The residual network
					  <math xmlns="http://www.w3.org/1998/Math/MathML">
						<msub>
						  <mi>G</mi>
						  <mi>f</mi>
						</msub>
					  </math>
					   corresponding to the flow is build as follows:</p>
					<p> Each edge
					  <math xmlns="http://www.w3.org/1998/Math/MathML">
						<mo stretchy="false">(</mo>
						<mi>v</mi>
						<mo>,</mo>
						<mi>w</mi>
						<mo stretchy="false">)</mo>
						<mo>&#x2208;<!-- ∈ --></mo>
						<mi>G</mi>
					  </math>
					   is replaced by two new edges
					   <math xmlns="http://www.w3.org/1998/Math/MathML">
						 <mo stretchy="false">(</mo>
						 <mi>v</mi>
						 <mo>,</mo>
						 <mi>w</mi>
						 <mo stretchy="false">)</mo>
					   </math>
					   and
					   <math xmlns="http://www.w3.org/1998/Math/MathML">
						 <mo stretchy="false">(</mo>
						 <mi>w</mi>
						 <mo>,</mo>
						 <mi>v</mi>
						 <mo stretchy="false">)</mo>
					   </math>.</p>
					   <p> The edge
					   <math xmlns="http://www.w3.org/1998/Math/MathML">
						 <mo stretchy="false">(</mo>
						 <mi>v</mi>
						 <mo>,</mo>
						 <mi>w</mi>
						 <mo stretchy="false">)</mo>
					   </math>
						has cost
						<math xmlns="http://www.w3.org/1998/Math/MathML">
						  <mi>c</mi>
						  <mo stretchy="false">(</mo>
						  <mi>v</mi>
						  <mo>,</mo>
						  <mi>w</mi>
						  <mo stretchy="false">)</mo>
						</math>
						 and residual capacity
						 <math xmlns="http://www.w3.org/1998/Math/MathML">
						   <mi>r</mi>
						   <mo stretchy="false">(</mo>
						   <mi>v</mi>
						   <mo>,</mo>
						   <mi>w</mi>
						   <mo stretchy="false">)</mo>
						   <mo>=</mo>
						   <mi>u</mi>
						   <mo stretchy="false">(</mo>
						   <mi>v</mi>
						   <mo>,</mo>
						   <mi>w</mi>
						   <mo stretchy="false">)</mo>
						   <mo>&#x2212;<!-- − --></mo>
						   <mi>f</mi>
						   <mo stretchy="false">(</mo>
						   <mi>v</mi>
						   <mo>,</mo>
						   <mi>w</mi>
						   <mo stretchy="false">)</mo>
						   <mo>&gt;</mo>
						   <mn>0</mn>
						 </math>
						  , where
						  <math xmlns="http://www.w3.org/1998/Math/MathML">
							<mi>u</mi>
							<mo stretchy="false">(</mo>
							<mi>v</mi>
							<mo>,</mo>
							<mi>w</mi>
							<mo stretchy="false">)</mo>
						  </math>
						   is the capacity of the edge and
						   <math xmlns="http://www.w3.org/1998/Math/MathML">
							 <mi>f</mi>
							 <mo stretchy="false">(</mo>
							 <mi>v</mi>
							 <mo>,</mo>
							 <mi>w</mi>
							 <mo stretchy="false">)</mo>
						   </math>
							is the flow of edge.</p>
							<p> The second edge
							<math xmlns="http://www.w3.org/1998/Math/MathML">
							  <mo stretchy="false">(</mo>
							  <mi>w</mi>
							  <mo>,</mo>
							  <mi>v</mi>
							  <mo stretchy="false">)</mo>
							</math>
							 has cost
							 <math xmlns="http://www.w3.org/1998/Math/MathML">
							   <mi>c</mi>
							   <mo stretchy="false">(</mo>
							   <mi>w</mi>
							   <mo>,</mo>
							   <mi>v</mi>
							   <mo stretchy="false">)</mo>
							   <mo>=</mo>
							   <mo>&#x2212;<!-- − --></mo>
							   <mi>c</mi>
							   <mo stretchy="false">(</mo>
							   <mi>v</mi>
							   <mo>,</mo>
							   <mi>w</mi>
							   <mo stretchy="false">)</mo>
							 </math>
							  and residual capacity
							  <math xmlns="http://www.w3.org/1998/Math/MathML">
								<mi>r</mi>
								<mo stretchy="false">(</mo>
								<mi>w</mi>
								<mo>,</mo>
								<mi>v</mi>
								<mo stretchy="false">)</mo>
								<mo>=</mo>
								<mi>f</mi>
								<mo stretchy="false">(</mo>
								<mi>v</mi>
								<mo>,</mo>
								<mi>w</mi>
								<mo stretchy="false">)</mo>
								<mo>&gt;</mo>
								<mn>0</mn>
							  </math>.
							</p>							
							</p>
							
							
							<h3>Read more about residual networks: </h3>
							
							
							<button id="ta_button_gotoIdee">Read detailed description of a residual network</button>
							</div>
							
							<div id = "explanation-find-shortestpath">
								<h3> Find shortest path </h3>
								<p> The algorithm determines the shortest distances <math><mi>d</mi><mo stretchy="false">(</mo><mi>s</mi><mo>,</mo><mi>v</mi><mo stretchy="false">)</mo></math> from the excess node <math><mi>s</mi></math> to every node <math><mi>v</mi><mo>&#x2208;<!--∈--></mo><mi>V</mi></math> in the residual network <math><msub><mi>G</mi><mi>f</mi></msub></math> with respect to the reduced costs <math>
								  <msubsup>
									<mi>c</mi>
									<mrow class="MJX-TeXAtom-ORD">
									  <mi>v</mi>
									  <mo>,</mo>
									  <mi>w</mi>
									</mrow>
									<mrow class="MJX-TeXAtom-ORD">
									  <msup>
										<mi>p</mi>
										<mo>&#x2032;</mo>
									  </msup>
									</mrow>
								  </msubsup>
								</math>. By finding all shortest distances \(\mathcal d(v,s) \)  the algorithm also finds the shortest path \(\mathcal P \) from \(\mathcal s \) to \(\mathcal t \).
								</p>
								<p> In the current implementation of this applet the shortest distances \(\mathcal d(s,v) \) and the shortest path \(\mathcal P \) are found with the <a href="https://www-m9.ma.tum.de/graph-algorithms/spp-bellman-ford/index_en.html">Bellman-Ford algorithm </a>. One can also use <a href = "https://www-m9.ma.tum.de/graph-algorithms/spp-dijkstra/index_en.html"> Dijkstra </a> algorithm,or any other algorithm for finding shortest paths. Note that the distance between two nodes is the cost of the edge connecting the nodes.
								</p>
								
							</div>
							<div id = "explanation-update-potentials">
								<h3> Update potentials </h3>
								<p>At the begining of the algorithm the potentials for all nodes are set to 0. Then at every iteration the potentials <math><mi>p</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></math> for every node \(\mathcal v&isin;V \) are updated with respect to the old potentials and the calculated distances <math><mi>d</mi><mo stretchy="false">(</mo><mi>s</mi><mo>,</mo><mi>v</mi><mo stretchy="false">)</mo></math>.
								</p>
								<p>The potentisals are updated as follows:
								  <math display="block">
								  <msup>
									<mi>p</mi>
									<mo>&#x2032;</mo>
								  </msup>
								  <mo stretchy="false">(</mo>
								  <mi>v</mi>
								  <mo stretchy="false">)</mo>
								  <mo>=</mo>
								  <mi>p</mi>
								  <mo stretchy="false">(</mo>
								  <mi>v</mi>
								  <mo stretchy="false">)</mo>
								  <mo>&#x2212;<!-- − --></mo>
								  <mi>d</mi>
								  <mo stretchy="false">(</mo>
								  <mi>s</mi>
								  <mo>,</mo>
								  <mi>v</mi>
								  <mo stretchy="false">)</mo>
								</math>
								</p>
							</div>
							<div id = "explanation-update-cost">
								<h3> Reduce the cost </h3>
								<p>
								Now with the updated potentials the algorithm is able to calculate the reduced costs <math>	   <msubsup>
									<mi>c</mi>
									<mrow class="MJX-TeXAtom-ORD">
									  <mi>v</mi>
									  <mo>,</mo>
									  <mi>w</mi>
									</mrow>
									<mrow class="MJX-TeXAtom-ORD">
									  <msup>
										<mi>p</mi>
										<mo>&#x2032;</mo>
									  </msup>
									</mrow>
								  </msubsup></math>. 
								The updated costs are calculated with the following formula:
								<math display="block">
								   <msubsup>
									<mi>c</mi>
									<mrow class="MJX-TeXAtom-ORD">
									  <mi>v</mi>
									  <mo>,</mo>
									  <mi>w</mi>
									</mrow>
									<mrow class="MJX-TeXAtom-ORD">
									  <msup>
										<mi>p</mi>
										<mo>&#x2032;</mo>
									  </msup>
									</mrow>
								  </msubsup>
								  <mo>=</mo>
								  <msub>
									<mi>c</mi>
									<mrow class="MJX-TeXAtom-ORD">
									  <mi>v</mi>
									  <mo>,</mo>
									  <mi>w</mi>
									</mrow>
								  </msub>
								  <mo>&#x2212;<!-- − --></mo>
								    <msup>
									<mi>p</mi>
									<mo>&#x2032;</mo>
									</msup>
								  <mo stretchy="false">(</mo>
								  <mi>v</mi>
								  <mo stretchy="false">)</mo>
								  <mo>+</mo>
								   <msup>
									<mi>p</mi>
									<mo>&#x2032;</mo>
									</msup>
								  <mo stretchy="false">(</mo>
								  <mi>w</mi>
								  <mo stretchy="false">)</mo>
								</math>
								</p>
								<p>The reduced cost <math>
								  <msubsup>
									<mi>c</mi>
									<mrow class="MJX-TeXAtom-ORD">
									  <mi>v</mi>
									  <mo>,</mo>
									  <mi>w</mi>
									</mrow>
									<mrow class="MJX-TeXAtom-ORD">
									  <msup>
										<mi>p</mi>
										<mo>&#x2032;</mo>
									  </msup>
									</mrow>
								  </msubsup>
								</math> for each edge <math xmlns="http://www.w3.org/1998/Math/MathML">
								  <mo stretchy="false">(</mo>
								  <mi>v</mi>
								  <mo>,</mo>
								  <mi>w</mi>
								  <mo stretchy="false">)</mo>
								  <mo>&#x2208;<!-- ∈ --></mo>
								  <mi>E</mi>
								</math> in a shortest path from node <math><mi>s</mi></math> to any other node are zero. 
								</p>
							</div>
							<div id = "explanation-apply-augmentation-path">
								<h3> Augment flow through the shortest path </h3>
								<p>In this step the algorithm calculates the maximal amount of flow that can be augmentet through the shortest path <math><mi>P</mi></math>. If this capacity exceeds the demand of node <math><mi>t</mi></math> then the algorithm augments <math><mi>b</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></math> units of flow along the shortest path. 
								</p>
								<p>We calculate the amount of flow that is to be augmentet with the following formula:
								<math display="block">
								  <mi>&#x03B4;<!-- δ --></mi>
								  <mo>=</mo>
								  <mi>m</mi>
								  <mi>i</mi>
								  <mi>n</mi>
								  <mo fence="false" stretchy="false">{</mo>
								  <mi>b</mi>
								  <mo stretchy="false">(</mo>
								  <mi>s</mi>
								  <mo stretchy="false">)</mo>
								  <mo>,</mo>
								  <mo>&#x2212;<!-- − --></mo>
								  <mi>b</mi>
								  <mo stretchy="false">(</mo>
								  <mi>t</mi>
								  <mo stretchy="false">)</mo>
								  <mo>,</mo>
								  <mi>m</mi>
								  <mi>i</mi>
								  <mi>n</mi>
								  <mo fence="false" stretchy="false">{</mo>
								  <mi>r</mi>
								  <mo stretchy="false">(</mo>
								  <mi>v</mi>
								  <mo>,</mo>
								  <mi>w</mi>
								  <mo stretchy="false">)</mo>
								  <mo>:</mo>
								  <mo stretchy="false">(</mo>
								  <mi>v</mi>
								  <mo>,</mo>
								  <mi>w</mi>
								  <mo stretchy="false">)</mo>
								  <mo>&#x2208;<!-- ∈ --></mo>
								  <mi>P</mi>
								  <mo fence="false" stretchy="false">}</mo>
								  <mo fence="false" stretchy="false">}</mo>
								</math>
								</p>
								<p> And <math><mi>&#x03B4;<!-- δ --></mi></math> units of flow are augmentet along the shortest path <math><mi>P</mi></math>.
								</p>
							</div>
							
							<div id = "explanation-finished">
								<h3> Finished </h3>
								The algorithm terminated with maximal flow of:
                                <p id="finalflow" class="algoInfoTD" style="color:green">-</p>
                              and minimal cost for the flow:
                                <p id="minCost" class="algoInfoTD" style="color:green">-</p>
                              </p>
                                <p> The excess of node <math><mi>s</mi></math> is zero and there are no more excess or demand nodes, therefore a feasible flow has been found.</p>
                                <h3>What now?</h3>
                                    <center><button id="ta_button_gotoId">Read the detiled description of the algorithm</button></center>
								 <h3> Test your knowledge on an exercise? </h3>
                                    <center><button id="ta_button_gotoExercise1" style="position:absolut">Exercise 1</button></center>
									<center><button id="ta_button_gotoExercise2" style="position:absolut">Exercise 2</button></center>
                               
							</div>
						</div>

					
						<div id="ta_div_statusVariables">
                            <h3>Variable State</h3>
                            <table class="algoInformationen">
                                <tr>
                                    <th class="algoInfoTH"><span>Shortest Path</span></th>
                                    <th class="algoInfoTH"><span>Distances</span></th>
									<th class="algoInfoTH"><span>&delta;</span></th>
                                </tr>
                                <tr>
                                    <td id="variable-value-shortestPath" class="algoInfoTD">-</td>
                                   <td id="variable-value-distances" class="algoInfoTD">-</td>
								   <td id="variable-value-delta" class="algoInfoTD">-</td>
                                </tr>
                            </table>
                        </div>
						
						<div class="PseudocodeWrapper" id="ta_div_statusPseudocode">
                            <div id="pseudocode-select-source">
                                <p>s &larr; pick(v)</p>
                            </div>
                            <div id="pseudocode-select-target">
                                <p>t &larr; pick(v)</p>
                            </div>
                            <div id="pseudocode-start-algorithm">
                                <p><strong>BEGIN</strong></p>
								<p>| (*Initialize max flow *)</p>
								<p>| Set: b(s) = max flow, b(t) = - max flow, </p>
								<p>|       b(v) = 0 for all v&isin;V\{s,t} </p>
								<p>|       p(v) = 0 for all v&isin;V </p>
                            </div>
							<div id="pseudocode-main-loop">
                                <p>| (* Main loop *)</p>
								<p>| <strong> WHILE</strong> (b(s)>0)<strong> DO</strong></p>
								<p>| | Build the residual network with</p> 
								<p>| | respect to the current flow </p>
								<p>| |</p>
							</div>
							<div id="pseudocode-find-shortestpath">
								<p>| | (* Find shortest path *)</p>
								<p>| | Execute BELLMAN-FORD ALGORITHM to</p>
								<p>| | find:</p>
								<p>| | 1.Shortest distances d(s,v), &forall;v&isin;V in <math><msub><mi>G</mi><mi>f</mi></msub></math></p> 
								<p>| | 2.The shortest path P from <strong>s</strong> to <strong>t</strong></p>
								<p>| |</p>
							</div>
							<div id="pseudocode-update-potentials">
								<p>| | (* Update potentials *)</p>
								<p>| | <strong>FOR ALL</strong> v&isin;V <strong>DO</strong>  </p>
								<p>| |     p(v) := p(v) - d(s,v)</p>
								<p>| |</p>
							</div>
							<div id="pseudocode-update-cost">
								<p>| | (* Reduce cost *)</p>
								<p>| | <strong>FOR ALL</strong> (v,w)&isin;E <strong>DO</strong>  </p>
								<p>| |     <math><msubsup><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><mi>v</mi><mo>,</mo> <mi>w</mi></mrow><mi>p</mi></msubsup></math> := <math><msub><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><mi>v</mi><mo>,</mo>  <mi>w</mi></mrow></msub></math> - p(v) + p(w)</p>
								<p>| |</p>
							</div>
							<div id="pseudocode-apply-augmentation-path">
								<p>| | (* Apply path *)</p>
								<p>| | <math><mi>&#x03B4;<!-- δ --></mi>
								  <mo>=</mo>
								  <mi>m</mi>
								  <mi>i</mi>
								  <mi>n</mi>
								  <mo fence="false" stretchy="false">{</mo>
								  <mi>b</mi>
								  <mo stretchy="false">(</mo>
								  <mi>s</mi>
								  <mo stretchy="false">)</mo>
								  <mo>,</mo>
								  <mo>&#x2212;<!-- − --></mo>
								  <mi>b</mi>
								  <mo stretchy="false">(</mo>
								  <mi>t</mi>
								  <mo stretchy="false">)</mo>
								  <mo>,</mo>
								  <mi>m</mi>
								  <mi>i</mi>
								  <mi>n</mi>
								  <mo fence="false" stretchy="false">{</mo>
								  <mi>r</mi>
								  <mo stretchy="false">(</mo>
								  <mi>v</mi>
								  <mo>,</mo>
								  <mi>w</mi>
								  <mo stretchy="false">)</mo>
								  <mo>:</mo>
								  <mo stretchy="false">(</mo>
								  <mi>v</mi>
								  <mo>,</mo>
								  <mi>w</mi>
								  <mo stretchy="false">)</mo>
								  <mo>&#x2208;<!-- ∈ --></mo>
								  <mi>P</mi>
								  <mo fence="false" stretchy="false">}</mo>
								  <mo fence="false" stretchy="false">}</mo>
								</math> </p>
								<p>| | Augment &delta; units of flow along the</p> 
								<p>| | path P</p>
							</div>
							<div id="pseudocode-finished">
								<p>| <strong>END WHILE</strong></p>
								<p><strong>END</strong></p>
                            </div>
                        </div>
					</div>
				</div>
				<div id="ta_div_confirmTabChange" title="Algorithmus abbrechen?" class="tabChangeWarningDialog">
                <h2>If the tab is changed the algorithm is terminated.</h2>
                <p>You can open <a href="#" target="_blank" tabindex=-1> another browser window</a> to read another tab in parallel.</p>
				</div>
			</div>

        </div>
			
	 <!-- TAB Beschreibung des Algorithmus -->		
			<div id="tab_ti" style="display: none;">
				<div id="ti_div_Einfuehrungstext">
				<h1>Minimum Cost Flow</h1>
				 <div class="BeispielbildContainer"><img id="ti_img_einfuehrung" src="img/graph-editor.svg" alt="Simple graph with 4 nodes."><p><strong>Figure 1. </strong> A directed graph with capacity and cost \( (u(e),c(e)) \) for every edge and a balance function \(b\) for every node. What's the cheapest way to send a flow with a magnitude of 4 from \(s\) to \(t\)?</p></div>
				<p>Finding a minimum cost flow in a network is one of the most important network flow problems. The actual optimization problem can be formulated as follows: Find the least-cost shipment of a specific amount of flow through a network with limited capacity of the edges. This model has numerous applications: routing of calls through a telephone system or data through networks, transporting products from a manufacturer to warehouse, and many more less obvious applications.</p>
				<p>The mathematical model corresponding to the minimum cost flow problem contains the following information: a directed graph \(G=(V,E)\), often called a network for simplicity; a limitation of the flow that can be sent along each edge in the network <math>
                    <mi>u</mi>
                    <mo stretchy="false">(</mo>
                    <mi>e</mi>
                    <mo stretchy="false">)</mo>
                    <mo>,</mo>
                    <mi>e</mi>
                    <mo>&#x2208;<!-- ∈ --></mo>
                    <mi>E</mi>
                  </math>, called capacity of the edge; and a cost function <math>
                    <mi>c</mi>
                    <mo stretchy="false">(</mo>
                    <mi>e</mi>
                    <mo stretchy="false">)</mo>
                    <mo>,</mo>
                    <mi>e</mi>
                    <mo>&#x2208;<!-- ∈ --></mo>
                    <mi>E</mi>
                  </math> which models the cost of sending a unit of flow along the corresponding edge, i.e., the flow cost varies linearly with the amount of flow. The integer numbers <math><mi>b</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></math> associated with each node <math><mi>v</mi><mo>&#x2208;<!-- ∈ --></mo><mi>V</mi></math> represent the supply/demand of the node. The model also requires a fixed source and target node.
				  </p>
				  <p>The flow <math><mi>f</mi></math> that solves the problem uses only the edges that minimize the sum of the product of the flow through an edge and the cost of the edge: Minimize \(\mathcal &sum;_{(v,w)&isin;E} f(v,w)*c(v,w) \). The solution has to satisfy the constraints for a feasible flow - each edge can carry up to <math>
                  <mi>u</mi>
                  <mo stretchy="false">(</mo>
                  <mi>e</mi>
                  <mo stretchy="false">)</mo>
                </math> units of flow, and \(b(v) = 0\) for every node \(v&isin;V\), with the exceptions of the source and the target nodes.
				</p>
				<p>The amount of flow that we want to send along the network should be fixed before attempting to optimize its cost. In this application, we are always interested in finding the cheapest way to send maximal amount of flow through the network, also known as the <strong>min-cost-max-flow problem</strong>. </p>
				<p>  </p>
                <p>  </p>
				
				<h1> Flow network </h1>
				 <div class="BeispielbildContainer">
                    <img id="ti_img_flow_network" src="img/maxflow-graph-algorithm-graph.svg"   alt="Network with 4 nodes and max flow."><p><strong>Figure 2.</strong> Flow network <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>N</mi>
                    </math> with calculated maximal flow
                      <math xmlns="http://www.w3.org/1998/Math/MathML">
                        <mi>f</mi>
                      </math> (without considering the costs), edge parameters <math xmlns="http://www.w3.org/1998/Math/MathML">
                          <mo stretchy="false">(</mo>
                          <mi>f</mi>
                          <mo stretchy="false">(</mo>
                          <mi>e</mi>
                          <mo stretchy="false">)</mo>
                          <mrow class="MJX-TeXAtom-ORD">
                            <mo>/</mo>
                          </mrow>
                          <mi>u</mi>
                          <mo stretchy="false">(</mo>
                          <mi>e</mi>
                          <mo stretchy="false">)</mo>
                          <mo>,</mo>
                          <mi>c</mi>
                          <mo stretchy="false">(</mo>
                          <mi>e</mi>
                          <mo stretchy="false">)</mo>
                          <mo stretchy="false">)</mo>
                        </math>, and node balances \(\mathcal b(v) \).</p>
                </div>
				<p>Let \( G = (V,E) \) be a weighted digraph defined by a set of nodes <math><mi>V</mi></math>, a set of directed edges <math><mi>E</mi></math>\(\mathcal = {(v,w): v,w &isin; V} \) where each edge has a capacity function \(\mathcal u(e): e&isin;E\) that denotes the maximal amount of flow that can be sent over the edge \(\mathcal e \), and a cost function \(\mathcal c(e): e&isin;E\) that denotes how expensive it is to send a unit of flow along the edge \(\mathcal e \). Let us also associate with each node \(\mathcal v&isin;V \) an integer number \(\mathcal b(v) \) representing its supply/demand. <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
                  <mi>v</mi>
				  <mo>&#xA0;</mo>
				  <mi>i</mi>
				  <mi>s</mi>				  
                  <mrow>
                    <mo>{</mo>
                    <mtable columnalign="left left" rowspacing=".2em" columnspacing="1em" displaystyle="false">
                      <mtr>
                        <mtd>
                          <mtext> demand node&#xA0;</mtext>
                        </mtd>
                        <mtd>
                          <mtext>, if&#xA0;</mtext>
                          <mi>b</mi>
                          <mo stretchy="false">(</mo>
                          <mi>v</mi>
                          <mo stretchy="false">)</mo>
                          <mo>&lt;</mo>
                          <mn>0</mn>
                        </mtd>
                      </mtr>
                     <mtr>
                        <mtd>
                          <mtext> supply node&#xA0;</mtext>
                        </mtd>
                        <mtd>
                          <mtext>, if&#xA0;</mtext>
                          <mi>b</mi>
                          <mo stretchy="false">(</mo>
                          <mi>v</mi>
                          <mo stretchy="false">)</mo>
                          <mo>&gt;</mo>
                          <mn>0</mn>
                        </mtd>
                      </mtr>
                     <mtr>
                        <mtd>
                          <mtext> transshipment node&#xA0;</mtext>
                        </mtd>
                        <mtd>
                          <mtext>, if&#xA0;</mtext>
                          <mi>b</mi>
                          <mo stretchy="false">(</mo>
                          <mi>v</mi>
                          <mo stretchy="false">)</mo>
                          <mo>=</mo>
                          <mn>0</mn>
                        </mtd>
                      </mtr>
                    </mtable>
                    <mo fence="true" stretchy="true" symmetric="true"></mo>
                  </mrow>
                </math></p>
				<p>The set of all incoming edges of a node
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>v</mi>
                </math> is defined as
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <msup>
                    <mi>N</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>i</mi>
                      <mi>n</mi>
                    </mrow>
                  </msup>
                  <mo>:=</mo>
                  <mo fence="false" stretchy="false">{</mo>
                  <mi>w</mi>
                  <mo>&#x2208;<!-- ∈ --></mo>
                  <mi>V</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo stretchy="false">|</mo>
                  </mrow>
                  <mo stretchy="false">(</mo>
                  <mi>w</mi>
                  <mo>,</mo>
                  <mi>v</mi>
                  <mo stretchy="false">)</mo>
                  <mo>&#x2208;<!-- ∈ --></mo>
                  <mi>E</mi>
                  <mo fence="false" stretchy="false">}</mo>
                </math> and the set of all outgoing edges of node
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>v</mi>
                </math> is
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <msup>
                    <mi>N</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>o</mi>
                      <mi>u</mi>
                      <mi>t</mi>
                    </mrow>
                  </msup>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo stretchy="false">)</mo>
                  <mo>:=</mo>
                  <mo fence="false" stretchy="false">{</mo>
                  <mi>w</mi>
                  <mo>&#x2208;<!-- ∈ --></mo>
                  <mi>V</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo stretchy="false">|</mo>
                  </mrow>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                  <mo>&#x2208;<!-- ∈ --></mo>
                  <mi>E</mi>
                  <mo fence="false" stretchy="false">}</mo>
                </math>. Let also
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>d</mi>
                  <mi>e</mi>
                  <msup>
                    <mi>g</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>i</mi>
                      <mi>n</mi>
                    </mrow>
                  </msup>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo stretchy="false">)</mo>
                  <mo>:=</mo>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo stretchy="false">|</mo>
                  </mrow>
                  <msup>
                    <mi>N</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>i</mi>
                      <mi>n</mi>
                    </mrow>
                  </msup>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo stretchy="false">)</mo>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo stretchy="false">|</mo>
                  </mrow>
                </math> and
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>d</mi>
                  <mi>e</mi>
                  <msup>
                    <mi>g</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>o</mi>
                      <mi>u</mi>
                      <mi>t</mi>
                    </mrow>
                  </msup>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo stretchy="false">)</mo>
                  <mo>:=</mo>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo stretchy="false">|</mo>
                  </mrow>
                  <msup>
                    <mi>N</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>o</mi>
                      <mi>u</mi>
                      <mi>t</mi>
                    </mrow>
                  </msup>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo stretchy="false">)</mo>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo stretchy="false">|</mo>
                  </mrow>
                </math> be the number of incoming edges and the number of outgoing edges for node \(\mathcal v \), respectively.</p>
				<p>With this knowledge, we can define a flow network as follows: \(\mathcal N = (V,E,s,t,u)\) is a directed graph with a source node \(\mathcal s \) and a target node \(\mathcal t \) with  <math>
                  <mi>d</mi>
                  <mi>e</mi>
                  <msup>
                    <mi>g</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>i</mi>
                      <mi>n</mi>
                    </mrow>
                  </msup>
                  <mo stretchy="false">(</mo>
                  <mi>s</mi>
                  <mo stretchy="false">)</mo>
                  <mo>=</mo>
				  <mi>d</mi>
                  <mi>e</mi>
                  <msup>
                    <mi>g</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>o</mi>
                      <mi>u</mi>
					  <mi>t</mi>
                    </mrow>
                  </msup>
                  <mo stretchy="false">(</mo>
                  <mi>t</mi>
                  <mo stretchy="false">)</mo>
                  <mo>=</mo>
				  <mn>0</mn>
				  </math>, and a capacity function \(\mathcal u(v,w) \) for every edge \(\mathcal (v,w) &isin; E \). A flow \(\mathcal f \) in \(\mathcal N \) is a mapping \(\mathcal f(e): E&rarr;[0;&#x221e;)\) that satisfies the properties for a feasible flow.</p>
				<p> \(\mathcal (1) f(e)&le;u(e), &forall;e&isin;E\).</p>
				<p> \(\mathcal (2) \) <math>
                    <munder>
                      <mo>&#x2211;<!-- ∑ --></mo>
                      <mrow class="MJX-TeXAtom-ORD">
                        <mi>w</mi>
                        <mo>&#x2208;<!-- ∈ --></mo>
                        <msup>
                          <mi>N</mi>
                          <mrow class="MJX-TeXAtom-ORD">
                            <mi>i</mi>
                            <mi>n</mi>
                          </mrow>
                        </msup>
                        <mo stretchy="false">(</mo>
                        <mi>v</mi>
                        <mo stretchy="false">)</mo>
                      </mrow>
                    </munder>
                    <mi>f</mi>
                    <mo stretchy="false">(</mo>
                    <mi>w</mi>
                    <mo>,</mo>
                    <mi>v</mi>
                    <mo stretchy="false">)</mo>
                    <mo>=</mo>
                    <munder>
                      <mo>&#x2211;<!-- ∑ --></mo>
                      <mrow class="MJX-TeXAtom-ORD">
                        <mi>w</mi>
                        <mo>&#x2208;<!-- ∈ --></mo>
                        <msup>
                          <mi>N</mi>
                          <mrow class="MJX-TeXAtom-ORD">
                            <mi>o</mi>
                            <mi>u</mi>
                            <mi>t</mi>
							 </msup>
							 <mo stretchy="false">(</mo>
							<mi>v</mi>
							<mo stretchy="false">)</mo>
                          </mrow>
                          </mrow>
                      </mrow>
                    </munder>
                    <mi>f</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>,</mo>
                    <mtext>&#xA0;</mtext>
                    <mi mathvariant="normal">&#x2200;<!-- ∀ --></mi>
                    <mi>v</mi>
                    <mo>&#x2208;<!-- ∈ --></mo>
                    <mi>V</mi>
                    <mtext>&#xA0;\&#xA0;</mtext>
                    <mo fence="false" stretchy="false">{</mo>
                    <mi>s</mi>
                    <mo>,</mo>
                    <mi>t</mi>
                    <mo fence="false" stretchy="false">}</mo>
                  </math>. </p>
				      <div class="BeispielbildContainer"><img id="ti_img_be08" src="img/be08.svg" alt="Transformation."><p><strong>Figure 3.</strong> Transformation of parallel edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <msub>
                        <mi>e</mi>
                        <mn>1</mn>
                      </msub>
                      <mo>=</mo>
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                    </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <msub>
                      <mi>e</mi>
                      <mn>2</mn>
                    </msub>
                    <mo>=</mo>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> with equal costs.</p>
                </div>
				  <p>The first property is called <strong>capacity constraint</strong> and states that the amount of flow that goes through an edge \(\mathcal e \) cannot exceed the capacity of the edge itself. The second property states that the amount of flow arriving at a node <math>
					<mi>v</mi>
                    <mo>&#x2208;<!-- ∈ --></mo>
                    <mi>V</mi>
                    <mtext>&#xA0;\&#xA0;</mtext>
                    <mo fence="false" stretchy="false">{</mo>
                    <mi>s</mi>
                    <mo>,</mo>
                    <mi>t</mi>
                    <mo fence="false" stretchy="false">}</mo>
                  </math> has to be the same amount of flow that leaves the node. For the source and target nodes must hold: <math>
                    <munder>
                      <mo>&#x2211;<!-- ∑ --></mo>
                      <mrow class="MJX-TeXAtom-ORD">
                        <mi>w</mi>
                        <mo>&#x2208;<!-- ∈ --></mo>
                        <msup>
                          <mi>N</mi>
                          <mrow class="MJX-TeXAtom-ORD">
                            <mi>o</mi>
                            <mi>u</mi>
							<mi>t</mi>
                          </mrow>
                        </msup>
                        <mo stretchy="false">(</mo>
                        <mi>s</mi>
                        <mo stretchy="false">)</mo>
                      </mrow>
                    </munder>
                    <mi>f</mi>
                    <mo stretchy="false">(</mo>
                    <mi>s</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>=</mo>
                    <munder>
                      <mo>&#x2211;<!-- ∑ --></mo>
                      <mrow class="MJX-TeXAtom-ORD">
                        <mi>w</mi>
                        <mo>&#x2208;<!-- ∈ --></mo>
                        <msup>
                          <mi>N</mi>
                          <mrow class="MJX-TeXAtom-ORD">
						    <mi>i</mi>
                            <mi>n</mi>
							 </msup>
							 <mo stretchy="false">(</mo>
							<mi>t</mi>
							<mo stretchy="false">)</mo>
                          </mrow>
                      </mrow>
                    </munder>
                    <mi>f</mi>
                    <mo stretchy="false">(</mo>
                    <mi>w</mi>
                    <mo>,</mo>
                    <mi>t</mi>
                    <mo stretchy="false">)</mo>
                  </math>, or: The flow amount leaving \(\mathcal s \) should be the same amount of flow arriving at \(\mathcal t \). </p>
				  <p>Every node in \(\mathcal N \) is associated with a balance function \(\mathcal b(v), v&isin;V \) that represents its supply/demand as explained above, and with the second constraint follows that \(b(s) = -b(t)\). For this applet the cost function must be non-negative \(c(v,w)&ge;0 \). The total cost of the flow is calculated as
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <munder>
                      <mo>&#x2211;<!-- ∑ --></mo>
                      <mrow class="MJX-TeXAtom-ORD">
                        <mi>e</mi>
                        <mo>&#x2208;<!-- ∈ --></mo>
                        <mi>E</mi>
                      </mrow>
                    </munder>
                    <mi>f</mi>
                    <mo stretchy="false">(</mo>
                    <mi>e</mi>
                    <mo stretchy="false">)</mo>
                    <mo>&#x2217;<!-- ∗ --></mo>
                    <mi>c</mi>
                    <mo stretchy="false">(</mo>
                    <mi>e</mi>
                    <mo stretchy="false">)</mo>
                  </math>.</p>
				  <p>
                  The structure of the flow network can lead to some inconsistencies which because of the cost can only be avoided with a network transformation.
                  That is the reason why in this applet some additional conditions are posed. In order for the applet to function correctly, we forbid parallel edges. Parallel edges are edges that start from the same node and end in the same node, i.e <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <msub>
                      <mi>e</mi>
                      <mn>1</mn>
                    </msub>
                    <mo>=</mo>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <msub>
                      <mi>e</mi>
                      <mn>2</mn>
                    </msub>
                    <mo>=</mo>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math>.
                
                If there were no costs associated with the edges, we could simply sum the capacities of those edges and combine
                them in one edge <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>e</mi>
                    <mo>=</mo>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    </math>.
					
					<div class="BeispielbildContainer"><img id="ti_img_be08" src="img/fig4.svg" alt="Transformation."><p><strong>Figure 4.</strong> Transformation of two parallel edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <msub>
                    <mi>e</mi>
                    <mn>1</mn>
                  </msub>
                  <mo>=</mo>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <msub>
                    <mi>e</mi>
                    <mn>2</mn>
                  </msub>
                  <mo>=</mo>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                </math> with different costs.</p>
                </div>
				
                    This transformation can also be valid if the costs of the both edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <msub>
                        <mi>e</mi>
                        <mn>1</mn>
                      </msub>
                    </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <msub>
                      <mi>e</mi>
                      <mn>2</mn>
                    </msub>
                  </math> are equal, as shown in Figure 3, which is unfortunately not always the case. If the costs of the edges are not equal, one will need to transform the flow network further.
                  If there exist two edges \(e_1\) and \(e_2\) with the same start and end nodes \(v\) and \(w\), a new node \(k\) is added to the flow network and one of the parallel edges is redirected through this node, this means, that one of the edges
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <msub>
                      <mi>e</mi>
                      <mi>i</mi>
                    </msub>
                    <mtext>,&#xA0;</mtext>
                    <mi>i</mi>
                    <mo>=</mo>
                    <mo fence="false" stretchy="false">{</mo>
                    <mn>1</mn>
                    <mo>,</mo>
                    <mn>2</mn>
                    <mo fence="false" stretchy="false">}</mo>
                  </math>, without loss of generality, let us say <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <msub>
                      <mi>e</mi>
                      <mn>2</mn>
                    </msub>
                  </math>, is replaced by the two new edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>k</mi>
                    <mo stretchy="false">)</mo>
                  </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>k</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> where <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>k</mi>
                    <mo stretchy="false">)</mo>
                  </math> has the same cost and capacity as the edge <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <msub>
                        <mi>e</mi>
                        <mn>2</mn>
                      </msub>
                    </math> and the second edge <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>k</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> has again the same capacity as \(e_2\) and cost <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>c</mi>
                    <mo stretchy="false">(</mo>
                    <mi>k</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>=</mo>
                    <mn>0</mn>
                  </math>, so that the transformation does not influence the cost of the flow. This transformation is illustrated in Figure 4.
                </p>
                <p> Another notational problem concerns the opposite edges. Two edges are opposite, if the start node of the first edge is the same as the end node of the second edge and the end node of the first edge is the same as the start node of the second one: <math xmlns="http://www.w3.org/1998/Math/MathML">
                <msub>
                  <mi>e</mi>
                  <mn>1</mn>
                </msub>
                <mo>=</mo>
                <mo stretchy="false">(</mo>
                <mi>v</mi>
                <mo>,</mo>
                <mi>w</mi>
                <mo stretchy="false">)</mo>
              </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
                <msub>
                  <mi>e</mi>
                  <mn>2</mn>
                </msub>
                <mo>=</mo>
                <mo stretchy="false">(</mo>
                <mi>w</mi>
                <mo>,</mo>
                <mi>v</mi>
                <mo stretchy="false">)</mo>
              </math>. If the costs of the both edges are equal, the transformation is easy. We can remove the edge with the smaller capacity by subtracting it from the capacity of the other edge, as shown in Figure 5. If the costs are not equal, both edges have to remain in some form in the flow network. This can be achieved with similar transformation as for the parallel edges with different costs from above. The transformation for opposite edges with different costs is presented in Figure 6.

              <div class="BeispielbildContainer"><img id="ti_img_be08" src="img/fig5.svg" alt="Transformation."><p><strong>Figure 5.</strong>Transformation of opposite edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                <msub>
                  <mi>e</mi>
                  <mn>1</mn>
                </msub>
                <mo>=</mo>
                <mo stretchy="false">(</mo>
                <mi>v</mi>
                <mo>,</mo>
                <mi>w</mi>
                <mo stretchy="false">)</mo>
              </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msub>
                <mi>e</mi>
                <mn>2</mn>
              </msub>
              <mo>=</mo>
              <mo stretchy="false">(</mo>
              <mi>v</mi>
              <mo>,</mo>
              <mi>w</mi>
              <mo stretchy="false">)</mo>
            </math> with equal costs.</p>
			</div> 
			<h1>Residual network </h1>
                <p> In order to work with flows, one often makes use of residual networks, for example, to find the maximal flow or to calculate the minimal cost for a flow in a network. The concept of residual networks is based on the following intuitive idea. If an edge
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>&#x2208;<!-- ∈ --></mo>
                    <mi>E</mi>
                  </math> carries <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>f</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> units of flow, then we can send additional <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>u</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>&#x2212;<!-- − --></mo>
                    <mi>f</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> units of flow from node <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>v</mi>
                  </math> to node <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>w</mi>
                  </math> along the edge   <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                      <mo>&#x2208;<!-- ∈ --></mo>
                      <mi>E</mi>
                  </math>. We can also cancel (some of) the existing flow on the edge <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                      <mo>&#x2208;<!-- ∈ --></mo>
                      <mi>E</mi>
                    </math> by sending up to <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>f</mi>
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                    </math> units of flow from node <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>w</mi>
                    </math> to node <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>v</mi>
                    </math>. While sending a unit of flow from node <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>v</mi>
                    </math> to node <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>w</mi>
                    </math> over the edge <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                      <mo>&#x2208;<!-- ∈ --></mo>
                      <mi>E</mi>
                    </math> increases the flow cost by <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>c</mi>
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                    </math>, sending a unit of flow from node <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>w</mi>
                    </math> to node <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>v</mi>
                    </math> decreases the flow cost by <math xmlns="http://www.w3.org/1998/Math/MathML">
                      <mi>c</mi>
                      <mo stretchy="false">(</mo>
                      <mi>v</mi>
                      <mo>,</mo>
                      <mi>w</mi>
                      <mo stretchy="false">)</mo>
                    </math>.
                </p>
                <p>
                  By using these ideas, we define the residual network <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <msub>
                      <mi>N</mi>
                      <mi>f</mi>
                    </msub>
                  </math>
                   with respect to a given flow <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>f</mi>
                  </math> as follows:
                  <div class="BeispielbildContainer"><img id="ti_img_be08" src="img/fig6.svg" alt="Transformation."><p><strong>Figure 6.</strong>Transformation of two opposite edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <msub>
                    <mi>e</mi>
                    <mn>1</mn>
                  </msub>
                  <mo>=</mo>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                </math> and <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <msub>
                    <mi>e</mi>
                    <mn>2</mn>
                  </msub>
                  <mo>=</mo>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                </math> with different costs.</p>
				</div>
                   Each edge
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>&#x2208;<!-- ∈ --></mo>
                    <mi>E</mi>
                  </math> in the original network is replaced by two new edges
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> and
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>w</mi>
                    <mo>,</mo>
                    <mi>v</mi>
                    <mo stretchy="false">)</mo>
                  </math>: the edge <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> has cost <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>c</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> and residual capacity
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>r</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>=</mo>
                    <mi>u</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>&#x2212;<!-- − --></mo>
                    <mi>f</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math> and the edge
                  <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mo stretchy="false">(</mo>
                    <mi>w</mi>
                    <mo>,</mo>
                    <mi>v</mi>
                    <mo stretchy="false">)</mo>
                  </math> has cost \(c(w,v) = -c(v,w)\) and residual capacity <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>r</mi>
                    <mo stretchy="false">(</mo>
                    <mi>w</mi>
                    <mo>,</mo>
                    <mi>v</mi>
                    <mo stretchy="false">)</mo>
                    <mo>=</mo>
                    <mi>f</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                  </math>  (see Figure 7.). The residual network consists only of edges with positive residual capacity, i.e. <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mi>r</mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>&gt;</mo>
                    <mn>0</mn>
                    <mtext>,&#xA0;</mtext>
                    <mi mathvariant="normal">&#x2200;<!-- ∀ --></mi>
                    <mo stretchy="false">(</mo>
                    <mi>v</mi>
                    <mo>,</mo>
                    <mi>w</mi>
                    <mo stretchy="false">)</mo>
                    <mo>&#x2208;<!-- ∈ --></mo>
                    <msub>
                      <mi>E</mi>
                      <mi>f</mi>
                    </msub>
                  </math>
                </p>
                To summarize, a residual network is defined as <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <msub>
                    <mi>N</mi>
                    <mi>f</mi>
                  </msub>
                  <mo>:=</mo>
                  <mo stretchy="false">(</mo>
                  <mi>V</mi>
                  <mo>,</mo>
                  <msub>
                    <mi>E</mi>
                    <mi>f</mi>
                  </msub>
                  <mo>,</mo>
                  <mi>s</mi>
                  <mo>,</mo>
                  <mi>t</mi>
                  <mo>,</mo>
                  <msub>
                    <mi>r</mi>
                  </msub>
                  <mo stretchy="false">)</mo>
                </math>, with
                <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
                  <msub>
                    <mi>r</mi>
                  </msub>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                  <mo>:=</mo>
                  <mrow>
                    <mo>{</mo>
                    <mtable columnalign="left left" rowspacing=".2em" columnspacing="1em" displaystyle="false">
                      <mtr>
                        <mtd>
                          <mi>u</mi>
                          <mo stretchy="false">(</mo>
                          <mi>v</mi>
                          <mo>,</mo>
                          <mi>w</mi>
                          <mo stretchy="false">)</mo>
                          <mo>&#x2212;<!-- − --></mo>
                          <mi>f</mi>
                          <mo stretchy="false">(</mo>
                          <mi>v</mi>
                          <mo>,</mo>
                          <mi>w</mi>
                          <mo stretchy="false">)</mo>
                        </mtd>
                        <mtd>
                          <mtext>, if&#xA0;</mtext>
                          <mi>f</mi>
                          <mo stretchy="false">(</mo>
                          <mi>v</mi>
                          <mo>,</mo>
                          <mi>w</mi>
                          <mo stretchy="false">)</mo>
                          <mo>&gt;</mo>
                          <mn>0</mn>
                        </mtd>
                      </mtr>
                      <mtr>
                        <mtd>
                          <mi>u</mi>
                          <mo stretchy="false">(</mo>
                          <mi>v</mi>
                          <mo>,</mo>
                          <mi>w</mi>
                          <mo stretchy="false">)</mo>
                          <mo>+</mo>
                          <mi>f</mi>
                          <mo stretchy="false">(</mo>
                          <mi>w</mi>
                          <mo>,</mo>
                          <mi>v</mi>
                          <mo stretchy="false">)</mo>
                        </mtd>
                        <mtd>
                          <mtext>, if&#xA0;</mtext>
                          <mi>f</mi>
                          <mo stretchy="false">(</mo>
                          <mi>w</mi>
                          <mo>,</mo>
                          <mi>v</mi>
                          <mo stretchy="false">)</mo>
                          <mo>&gt;</mo>
                          <mn>0</mn>
                        </mtd>
                      </mtr>
                      <mtr>
                        <mtd>
                          <mi>u</mi>
                          <mo stretchy="false">(</mo>
                          <mi>v</mi>
                          <mo>,</mo>
                          <mi>w</mi>
                          <mo stretchy="false">)</mo>
                        </mtd>
                        <mtd>
                          <mtext>, otherwise</mtext>
                        </mtd>
                      </mtr>
                    </mtable>
                    <mo fence="true" stretchy="true" symmetric="true"></mo>
                  </mrow>
                </math> and
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <msub>
                    <mi>E</mi>
                    <mi>f</mi>
                  </msub>
                  <mo>:=</mo>
                  <mo fence="false" stretchy="false">{</mo>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo stretchy="false">|</mo>
                  </mrow>
                  <msub>
                    <mi>r</mi>
                  </msub>
                  <mo stretchy="false">(</mo>
                  <mi>v</mi>
                  <mo>,</mo>
                  <mi>w</mi>
                  <mo stretchy="false">)</mo>
                  <mo>&gt;</mo>
                  <mn>0</mn>
                  <mo fence="false" stretchy="false">}</mo>
                </math>

              </p>

              <p>
                 <math xmlns="http://www.w3.org/1998/Math/MathML">

                            <mtext>&#xA0;</mtext>

                          </math>     </p>
				<div class="BeispielbildContainer"><img id="ti_img_res3" src="img/res1.svg" alt="Residual network of the original network."><p><strong>Figure 7.</strong> An edge <math>
                        <mi> e </mi>
                      </math> in a flow network, with flow, capacity, and cost <math xmlns="http://www.w3.org/1998/Math/MathML">
                        <mo stretchy="false">(</mo>
                        <mi>f</mi>
                        <mo stretchy="false">(</mo>
                        <mi>e</mi>
                        <mo stretchy="false">)</mo>
                        <mrow class="MJX-TeXAtom-ORD">
                          <mo>/</mo>
                        </mrow>
                        <mi>u</mi>
                        <mo stretchy="false">(</mo>
                        <mi>e</mi>
                        <mo stretchy="false">)</mo>
                        <mo>,</mo>
                        <mi>c</mi>
                        <mo stretchy="false">(</mo>
                        <mi>e</mi>
                        <mo stretchy="false">)</mo>
                        <mo stretchy="false">)</mo>
                      </math></p>
				</div>

              <p> However, the concept of residual networks can create some notational difficulties. This happens when the flow network contains both edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mo stretchy="false">(</mo>
                <mi>v</mi>
                <mo>,</mo>
                <mi>w</mi>
                <mo stretchy="false">)</mo>
                </math>
                and
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mo stretchy="false">(</mo>
                <mi>w</mi>
                <mo>,</mo>
                <mi>v</mi>
                <mo stretchy="false">)</mo>
              </math>. Then the residual network can contain two parallel edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mo stretchy="false">(</mo>
                <mi>v</mi>
                <mo>,</mo>
                <mi>w</mi>
                <mo stretchy="false">)</mo>
              </math> or <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mo stretchy="false">(</mo>
                <mi>w</mi>
                <mo>,</mo>
                <mi>v</mi>
                <mo stretchy="false">)</mo>
              </math> with different costs and residual capacities. If this happens, the edge
              <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mo stretchy="false">(</mo>
                <mi>v</mi>
                <mo>,</mo>
                <mi>w</mi>
                <mo stretchy="false">)</mo>
              </math> will no longer define a unique edge cost and residual capacity. That is why we assume, without loss of generality, that for every node pair <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mi>v</mi>
                <mtext>&#xA0;and&#xA0;</mtext>
                <mi>w</mi>
              </math> the flow network \(\mathcal N \) contains only one of the edges <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mo stretchy="false">(</mo>
                <mi>v</mi>
                <mo>,</mo>
                <mi>w</mi>
                <mo stretchy="false">)</mo>
              </math> or 
              <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mo stretchy="false">(</mo>
                <mi>w</mi>
                <mo>,</mo>
                <mi>v</mi>
                <mo stretchy="false">)</mo>
              </math>. If that is not the case we need to use the aforementioned transformations to remove one of the edges.
            </p>
			<p> To test your knowledge or read more about residual networks without cost function click <a href="https://www-m9.ma.tum.de/graph-algorithms/flow-ford-fulkerson/index_en.html">here</a>. And for an exercise on residual networks with cost function visit the <a href ="https://www-m9.ma.tum.de/graph-algorithms/flow-cycle-cancelling/index_en.html"> Cycle-Cancelling algorithm <a>.
			</p>
		<h1>Min-cost flow problem </h1>  
            <div class="BeispielbildContainer"><img id="ti_img_res3" src="img/res2.svg" alt="Transformation of an edge in residual network."><p><strong>Figure 8.</strong>
				The edge <math xmlns="http://www.w3.org/1998/Math/MathML">
				<mi>e</mi>
				</math> from Figure 7.</p>
			</div>
			<p>
              Let \(\mathcal N = (V,E,s,t,r)\) be a flow network,
              <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mi>c</mi>
                <mo>:</mo>
                <mi>E</mi>
                <mo stretchy="false">&#x2192;<!-- → --></mo>
                <mo stretchy="false">[</mo>
                <mn>0</mn>
                <mo>,</mo>
                <mi mathvariant="normal">&#x221E;<!-- ∞ --></mi>
                <mo stretchy="false">)</mo>
              </math> a cost function and <math xmlns="http://www.w3.org/1998/Math/MathML">
                <mi>d</mi>
                <mo>&#x2265;<!-- ≥ --></mo>
                <mn>0</mn>
              </math> the required flow amount. The problem: Find a flow \(f\) with magnitude \(d\) that has  minimal total cost:
                <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
                  <munder>
                    <mo>&#x2211;<!-- ∑ --></mo>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>e</mi>
                      <mo>&#x2208;<!-- ∈ --></mo>
                      <mi>E</mi>
                    </mrow>
                  </munder>
                  <mi>c</mi>
                  <mo stretchy="false">(</mo>
                  <mi>e</mi>
                  <mo stretchy="false">)</mo>
                  <mo>&#x22C5;<!-- ⋅ --></mo>
                  <mi>f</mi>
                  <mo stretchy="false">(</mo>
                  <mi>e</mi>
                  <mo stretchy="false">)</mo>
                  <mo>=</mo>
                  <mi>m</mi>
                  <mi>i</mi>
                  <mi>n</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo maxsize="2.047em" minsize="2.047em">{</mo>
                  </mrow>
                  <munder>
                    <mo>&#x2211;<!-- ∑ --></mo>
                    <mrow class="MJX-TeXAtom-ORD">
                      <mi>e</mi>
                      <mo>&#x2208;<!-- ∈ --></mo>
                      <mi>E</mi>
                    </mrow>
                  </munder>
                  <mi>c</mi>
                  <mo stretchy="false">(</mo>
                  <mi>e</mi>
                  <mo stretchy="false">)</mo>
                  <mo>&#x22C5;<!-- ⋅ --></mo>
                  <msup>
                    <mi>f</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <msup>
                        <mi></mi>
                        <mo>&#x2032;</mo>
                      </msup>
                    </mrow>
                  </msup>
                  <mo stretchy="false">(</mo>
                  <mi>e</mi>
                  <mo stretchy="false">)</mo>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo stretchy="false">|</mo>
                  </mrow>
                  <msup>
                    <mi>f</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <msup>
                        <mi></mi>
                        <mo>&#x2032;</mo>
                      </msup>
                    </mrow>
                  </msup>
                  <mo stretchy="false">(</mo>
                  <mi>e</mi>
                  <mo stretchy="false">)</mo>
                  <mtext>&#xA0;is flow in&#xA0;</mtext>
                 <mrow class="MJX-TeXAtom-ORD">
				<mi class="MJX-tex-caligraphic" mathvariant="script">N</mi>
				</mrow>
                  <mtext>&#xA0;with magnitude of &#xA0;</mtext>
                  <msup>
                    <mi>f</mi>
                    <mrow class="MJX-TeXAtom-ORD">
                      <msup>
                        <mi></mi>
                        <mo>&#x2032;</mo>
                      </msup>
                    </mrow>
                  </msup>
                  <mo>=</mo>
                  <mi>d</mi>
                  <mrow class="MJX-TeXAtom-ORD">
                    <mo maxsize="2.047em" minsize="2.047em">}</mo>
                  </mrow>
                </math>
				
                is called <strong>minimum cost flow problem</strong>. <!-- A feasible flow <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <mi>f</mi>
                </math> is an optimal solution of the minimum cost flow problem if and only if the <strong>reduced cost optimality condition</strong> holds.-->
            </p>

            <p>This applet uses the maximal flow as <math xmlns="http://www.w3.org/1998/Math/MathML">
              <mi>d</mi>
            </math>, i.e. it solves the <strong>min-cost-max-flow problem</strong>. </p>
       
			
			<div class="BeispielbildContainer"><img id="ti_img_sp" src="img/sp.svg" alt="First iteration of the algorithm."><p><strong>Figure 9.</strong>
			The algorithm has initialized the potentials \(p(v) = 0\) for all \(v&isin;V\). The maximal flow is 6, so the balance functions of \(s\) and \(t\) are \(b(s) = 6\) and \(b(t) = -6\). This is the first iteration of the algorithm, so the flow is 0, therefore the residual network is the same as the original network and the costs have not been reduced yet. The algorithm has found the shortest path \(\mathcal P\) in the residual network and it is marked in blue.</p>
			</div>
			
			
			<h1>Idea of the Successive-Shortest-Path algorithm </h1>
			
			<p>The successive-shortest-path algorithm is based on the <strong>reduced cost optimality condition</strong>. Each node \(\mathcal v&isin;V \) is associated with a real number \(\mathcal p(v) \), called a <strong>potential</strong>. For a set of node potentials \(\mathcal p(v) \), which are \(0\) for every node in the beginning of the algorithm, we define the <strong>reduced cost</strong> of an edge \(\mathcal (v,w)&isin;E\) as follows: <math>
			  <msubsup>
				<mi>c</mi>
				<mrow class="MJX-TeXAtom-ORD">
				  <mi>v</mi>
				  <mo>,</mo>
				  <mi>w</mi>
				</mrow>
				<mi>p</mi>
			  </msubsup>
			  <mo>=</mo>
			  <msub>
				<mi>c</mi>
				<mrow class="MJX-TeXAtom-ORD">
				  <mi>v</mi>
				  <mo>,</mo>
				  <mi>w</mi>
				</mrow>
			  </msub>
			  <mo>&#x2212;<!-- − --></mo>
			  <mi>p</mi>
			  <mo stretchy="false">(</mo>
			  <mi>i</mi>
			  <mo stretchy="false">)</mo>
			  <mo>+</mo>
			  <mi>p</mi>
			  <mo stretchy="false">(</mo>
			  <mi>j</mi>
			  <mo stretchy="false">)</mo>
			</math>. These costs are valid for the original network as well as for the residual network. We build the residual network the same way as before, but this time we use the reduced costs <math>
			  <msubsup>
				<mi>c</mi>
				<mrow class="MJX-TeXAtom-ORD">
				  <mi>v</mi>
				  <mo>,</mo>
				  <mi>w</mi>
				</mrow>
				<mi>p</mi>
			  </msubsup>
			</math> instead of the initial costs <math>  <msubsup><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><mi>v</mi><mo>,</mo><mi>w</mi></mrow></msubsup></math>. </p>
			<p> The reduced cost optimality condition states that a feasible flow \(\mathcal f \) is a minimum cost flow if and only if some set of node potentials \(\mathcal p(v) \) satisfy the following inequality: 
			<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
			  <msubsup>
				<mi>c</mi>
				<mrow class="MJX-TeXAtom-ORD">
				  <mi>v</mi>
				  <mo>,</mo>
				  <mi>w</mi>
				</mrow>
				<mi>p</mi>
			  </msubsup>
			  <mo>&#x2265;<!-- ≥ --></mo>
			  <mn>0</mn>
			  <mo>,</mo>
			  <mi mathvariant="normal">&#x2200;<!-- ∀ --></mi>
			  <mo stretchy="false">(</mo>
			  <mi>v</mi>
			  <mo>,</mo>
			  <mi>w</mi>
			  <mo stretchy="false">)</mo>
			  <mo>&#x2208;<!-- ∈ --></mo>
			  <msub>
				<mi>G</mi>
				<mi>f</mi>
			  </msub>
			</math> For this algorithm we assume that all costs are non-negative, because otherwise we won't be able to fulfill the reduced cost optimality condition right from the beginning of the algorithm. This assumption does not lead to loss of generality because of the <a href = "http://www.princeton.edu/~alaink/Orf467F13/Readings&AssignmentNetworks.pdf">arc reversal</a> transformation which transforms an edge with negative cost into an edge with non-negative cost.</p> 
			<p> Some algorithms for solving the min-cost flow problem, like the <a href="https://www-m9.ma.tum.de/graph-algorithms/flow-cycle-cancelling/index_en.html">Cycle-Cancelling algorithm</a>, first find a feasible flow in the network and then attempt to optimize it. The successive-shortest-path algorithm takes another approach. It maintains optimality of the flow and tries to attain feasibility. The successive-shortest-path algorithm maintains a solution \(\mathcal f \) that is non-negative and satisfies the capacity constraints, but violates the mass balance constraints of the nodes. The algorithm selects at every step an excess node and a demand node and sends some flow along a shortest path in the residual network from the node with excess supply to the node with the unfulfilled demand. In our applet the node with excess supply is always the node \(\mathcal s \) that we choose at the beginning of the algorithm as a source node, and the demand node is always the node \(\mathcal t \) that we choose as a target node. The algorithm terminates when all nodes in the network are transshipment (balanced) nodes, i.e. \(b(v) = 0 \) for every \(v&isin;V\),  with the current flow \(\mathcal f \). </p>
			
			<div class="BeispielbildContainer"><img id="ti_img_updatePotentials" src="img/update_potentials.svg" alt="First iteration of the algorithm update potentials."><p><strong>Figure 10.</strong>
			Updatet potentials of the network in Figure 9. After the algorithm calculates the shortest distances the potentials are updated according to the formula: \(p'(v) = p(v) - d(s,v)\).</p>
			</div>
			
			<p>So what exactly does the algorithm do? At the beginning the algorithm sets all potentials \(\mathcal p(v) \) to 0 and starts with a flow \(f=0\). In general, the algorithm gets also the desired amount of flow \(d\) as an input and \(d\) can be of any size, as long as it is less or equal to the maximal flow. Our applet calculates the min-cost-max-flow so we don't give \(d\) as an input but we calculate it at the beginning of the algorithm and before the max-flow is calculated we set the balance functions \(b(v)=0\) for every \(v&isin;V\). (If we were to give the desired flow as an input, we would initialize the balance functions of the excess and demand nodes at the begining as \(b(s) = d \) and \(b(t) = - d\).) After we have chosen a start node \(\mathcal s \) and a target node \(\mathcal t \) the algorithm calculates the maximal flow for the given network with the help of the <a href= "https://www-m9.ma.tum.de/graph-algorithms/flow-ford-fulkerson/index_en.html">Ford-Fulkerson algorithm</a>. Only then our applet sets the source node \(\mathcal s \) as a supply node with excess supply equal to the maximal flow \(\mathcal b(s) = max flow \), and the target node \(\mathcal t \) as a demand node with a demand of the maximal flow \(\mathcal b(t) = - max flow \). Then the algorithm enters the main loop in which it tests if the excess node \(\mathcal s \) still has excess supply or is balanced and constructs the residual network <math><msub><mi>G</mi><mi>f</mi></msub></math>. If \(\mathcal s \) still has more supply, then there must still exist a node with an unfulfilled demand which in our case is always \(t\). The algorithm uses the <a href="https://www-m9.ma.tum.de/graph-algorithms/spp-bellman-ford/index_en.html">Bellman-Ford</a> algorithm to find the shortest distances \(\mathcal d(s,v) \) from \(\mathcal s \) to every node \(\mathcal v&isin;V \) in the residual network with respect to the reduced costs <math><msubsup><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><mi>v</mi><mo>,</mo><mi>w</mi></mrow><mi>p</mi></msubsup></math> and thus also the shortest path \(\mathcal P \) from \(\mathcal s \) to the demand node \(\mathcal t \) marked in blue (Figure 9). In the next step the algorithm updates the potentials \(\mathcal p(v) \) of all nodes with the following formula: \(\mathcal p'(v) = p(v) - d(s,v) \) (Figure 10). When the potentials are updated, the reduced costs can be calculated as follows: <math>
				   <msubsup>
					<mi>c</mi>
					<mrow class="MJX-TeXAtom-ORD">
					  <mi>v</mi>
					  <mo>,</mo>
					  <mi>w</mi>
					</mrow>
					<mrow class="MJX-TeXAtom-ORD">
					  <msup>
						<mi>p</mi>
						<mo>&#x2032;</mo>
					  </msup>
					</mrow>
				  </msubsup>
				  <mo>=</mo>
				  <msub>
					<mi>c</mi>
					<mrow class="MJX-TeXAtom-ORD">
					  <mi>v</mi>
					  <mo>,</mo>
					  <mi>w</mi>
					</mrow>
				  </msub>
				  <mo>&#x2212;<!-- − --></mo>
				  <mi>p</mi>
				  <mo stretchy="false">(</mo>
				  <mi>v</mi>
				  <mo stretchy="false">)</mo>
				  <mo>+</mo>
				  <mi>p</mi>
				  <mo stretchy="false">(</mo>
				  <mi>w</mi>
				  <mo stretchy="false">)</mo>
				</math> (Figure 11). Then the algorithm calculates the maximal amount of flow that can be augmented along \(\mathcal P \) or if the capacity of \(\mathcal P \) is big enough, the remaining supply is augmented: <math>
				  <mi>&#x03B4;<!-- δ --></mi>
				  <mo>=</mo>
				  <mi>m</mi>
				  <mi>i</mi>
				  <mi>n</mi>
				  <mo fence="false" stretchy="false">{</mo>
				  <mi>b</mi>
				  <mo stretchy="false">(</mo>
				  <mi>s</mi>
				  <mo stretchy="false">)</mo>
				  <mo>,</mo>
				  <mo>&#x2212;<!-- − --></mo>
				  <mi>b</mi>
				  <mo stretchy="false">(</mo>
				  <mi>t</mi>
				  <mo stretchy="false">)</mo>
				  <mo>,</mo>
				  <mi>m</mi>
				  <mi>i</mi>
				  <mi>n</mi>
				  <mo fence="false" stretchy="false">{</mo>
				  <mi>r</mi>
				  <mo stretchy="false">(</mo>
				  <mi>v</mi>
				  <mo>,</mo>
				  <mi>w</mi>
				  <mo stretchy="false">)</mo>
				  <mo>:</mo>
				  <mo stretchy="false">(</mo>
				  <mi>v</mi>
				  <mo>,</mo>
				  <mi>w</mi>
				  <mo stretchy="false">)</mo>
				  <mo>&#x2208;<!-- ∈ --></mo>
				  <mi>P</mi>
				  <mo fence="false" stretchy="false">}</mo>
				  <mo fence="false" stretchy="false">}</mo>
				</math>. And then \(&delta;\) units of flow are augmented along the shortest path \(\mathcal P \). By augmenting \(&delta;\) flow units along the shortest path, the excess supply of \(s\) and the unfulfilled demand of \(t\) are reduced by \(&delta;\) units: \(b'(s) = b(s) - &delta;\) and \(b'(t) = b(t) + &delta;\) (see Figure 12). After that the algorithm goes back to the main loop to test for normalization. When \(\mathcal b(s) = 0 \) there should not be any more supply or demand nodes left, so the algorithm terminates and the current flow is the optimal flow.</p>
				<p>  </p>
			
				<h1>What now?</h1>
				
				<div class="BeispielbildContainer"><img id="ti_img_updatePotentials" src="img/update_applypath.svg" alt="First iteration of the algorithm apply path."><p><strong>Figure 12.</strong>
				Augment \(&delta;\) units of flow along the shortest path and update the balance functions of \(s\) and \(t\). After the algorithm has found the shortest path \(\mathcal P\) and has updated the potentials and costs, it calculates how many flow units can be augmented through the path: \(&delta; = min\{b(s),-b(t),min\{r(e)|e&isin;\mathcal P\}\} = min\{6,6,2\}=2\). Then it augments \(&delta;=2\) flow units along the path and updates the balance functions of \(s\) and \(t\): \(b'(s) = b(s) - &delta;=6-2=4\) and \(b'(t) = b(t) + &delta;=-6+2=-4\).</p>
				</div>
				
				
				<div class="BeispielbildContainer"><img id="ti_img_updatePotentials" src="img/update_cost.svg" alt="First iteration of the algorithm update cost."><p><strong>Figure 11.</strong>
				Reduced costs of the network in Figure 10. After the algorithm has the updated potentials for all nodes, the costs are reduced:<math> <msubsup>
					<mi>c</mi>
					<mrow class="MJX-TeXAtom-ORD">
					  <mi>v</mi>
					  <mo>,</mo>
					  <mi>w</mi>
					</mrow>
					<mrow class="MJX-TeXAtom-ORD">
					  <msup>
						<mi>p</mi>
						<mo>&#x2032;</mo>
					  </msup>
					</mrow>
				  </msubsup>
				  <mo>=</mo>
				  <msub>
					<mi>c</mi>
					<mrow class="MJX-TeXAtom-ORD">
					  <mi>v</mi>
					  <mo>,</mo>
					  <mi>w</mi>
					</mrow>
				  </msub>
				  <mo>&#x2212;<!-- − --></mo>
				  <mi>p</mi>
				  <mo stretchy="false">(</mo>
				  <mi>v</mi>
				  <mo stretchy="false">)</mo>
				  <mo>+</mo>
				  <mi>p</mi>
				  <mo stretchy="false">(</mo>
				  <mi>w</mi>
				  <mo stretchy="false">)</mo>
				</math>  .</p>
			</div>
			
				<br style="clear: both;" />
                <div class="Entscheidungsweg" id="ti_div_EntscheidungLeft">
                    <h3>Create a graph and play through the algorithm</h3>
                    <button id="ti_button_gotoDrawGraph">Try algorithm after creating a graph</button>
                    <button id="ti_button_gotoAlgorithm">Try algorithm on an example graph</button>
                </div>
                <!--<br style="clear: both;" />-->
				<div class="Entscheidungsweg" id="ti_div_EntscheidungRight">
                    <h3>Test your knowledge in the exercises</h3>
                    <button id="ti_button_gotoExercise1">Exercise: Choose the right answer. </button><br>
                    <button id="ti_button_gotoExercise2">Exercise: Fill out the missing fields.</button>
                </div>
                <br style="clear: both;" />
				</div>
			</div>
		

			
			
			<div id="tab_tf1" >
				<div>
					<div class="canvasWrapper">
                    <div class="svgContainer">
                    <svg class="graphCanvas" id="tf1_canvas_graph" width="700" height="450"></svg>
                    </div>
                    <a class="svgDownloader" download="graph-ex1.svg" href="data:text/plain,test">Download Graph</a>

                    <!-- Legende maximized-->

                    <div class="Legende">
						<h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>

						<div class="LegendeText">
							<table>
								<tr>
									<td class="LegendeTabelle"><img src="img/node.svg" alt="node" class="LegendeIcon"></td>
									<td><span>node</span></td>
								</tr>
								<tr>
									<td class="LegendeTabelle"><img src="img/node-st.svg" alt="node" class="LegendeIcon"></td>
									<td><span>source/target node</span></td>
								</tr>
								<tr>
									<td class="LegendeTabelle"><img src="img/node-excess.svg" alt="node" class="LegendeIcon"></td>
									<td><span>excess node</span></td>
								</tr>
								<tr>
									<td class="LegendeTabelle"><img src="img/node-demand.svg" alt="node" class="LegendeIcon"></td>
									<td><span>demand node</span></td>
								</tr>
								<tr>
									<td class="LegendeTabelle"><img src="img/edge-flow.svg" alt="edge" class="LegendeIcon"></td>
									<td><span>edge with capacity 10, flow 7 and cost 1</span></td>
								</tr>
								<tr>
									<td class="LegendeTabelle"><img src="img/edge-residual.svg" alt="edge" class="LegendeIcon"></td>
									<td><span>edge in residual network</span></td>
								</tr>
								<tr>
									<td class="LegendeTabelle"><img src="img/edge-sp.svg" alt="edge" class="LegendeIcon"></td>
									<td><span>edge in shortest path</span></td>
								</tr>
							</table>
						</div>
					</div>
                    <!-- Legende minimized -->
                    <div class="LegendeMinimized">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    </div>

                </div>
				<!-- rechter Teil -->

                <div id="tf1_div_statusWindow" class="statusWindow">
                   <center> <h2  id= "f1-start" class="">Choose a graph and try to answer the questions while running the algorithm!</h2>
					<h2 id = "f1_started"> Answer the questions while running the algorithm!</h2></center>
                   
					<!--<select name="graphSelector" id="tf1_graphSelector">
					<option selected = true label="graph1">graph1</option>
					<option label="graph2">graph2</option>
					<option label="graph3">graph3</option>						
					<option label="graph4">graph4</option>
					<option label="graph5">graph5</option>
					<option label="graph6">graph6</option>
					<option label="graph7">graph7</option>
					<option label="graph8">graph8</option>
					<option label="graph9">graph9</option>
					</select>-->

              <br>

              <button id="tf1_button_start">Start Exercise</button> 
                    <div id="tf1_div_abspielbuttons">
						<input  id="tf1_button_rewind" type="checkbox"><label for="tf1_button_rewind" id="tf1_button_text_rewind">rewind</label>
						
                        <button id="tf1_button_1Schritt">Next Step</button>

                        <input  id="tf1_button_vorspulen" type="checkbox"><label for="tf1_button_vorspulen" id="tf1_button_text_fastforward">Forward: Next question</label>

                        <span id="tf1_button_text_pause" style="display:none">Pause</span>
                    </div>
                    <div id="tf1_div_questionModal" class="ui-widget ui-widget-content ui-corner-all" style="display: none;">
                    </div>
                    <div id="tf1_div_statusTabs">
                         <ul>
                            <li><a href="#tf1_div_statusErklaerung">Explanation</a></li>
                            <li><a href="#tf1_div_statusPseudocode">Pseudocode</a></li>
                        </ul>
                        <!-- Status Erklärung -->
                        <div id="tf1_div_statusErklaerung">
							<div id = "fr-explanation-select-source">
								<h3> First choose a source node.</h3>
								<p> Please click on a node in the network to select it as the source/starting node <math xmlns="http://www.w3.org/1998/Math/MathML">
                                    <mstyle mathvariant="bold">
                                      <mi>s</mi>
                                    </mstyle>
                                  </math>. The flow is going to start from this node. It will have no incoming flow, but it will have outgoing flow (with the magnitude of the maximal feasible flow in the network) which makes it an excess node.
							</div>
							<div id = "fr-explanation-select-target">
								<h3> Then choose a target node.</h3>
								<p> Please click on a node in the network to select it as the sink/target node <math xmlns="http://www.w3.org/1998/Math/MathML">
                                    <mstyle mathvariant="bold">
                                      <mi>t</mi>
                                    </mstyle>
                                  </math>. The flow ends in this node. It will have no outgoing flow, but it will still have incoming flow (with the magnitude of the maximal feasible flow in the network) which makes it a demand node.
							</div>
							 <div id="fr-explanation-start-algorithm">
                                <h3>Successive Shortest Path algorithm</h3>
                                <p>Now the algorithm can begin. The maximal feasible flow in this graph is calculated with the help of the <a href = "https://www-m9.ma.tum.de/graph-algorithms/flow-ford-fulkerson/index_en.html"> Ford-Fulkerson algorithm</a>. The calculated flow is then set as an excess on the source node and as a demand on the target node: \(b(s) = max\ flow\) and \(b(t) = - max\ flow\).</p>
								<p>	Please click on <strong>next</strong> to start the algorithm.</p>
                            </div>
							<div id = "fr-explanation-main-loop"> 
								<h3> Entering the main loop </h3>
							<p>
							In the main loop the algorithm repeatedly tests for normalization with the condition \(\mathcal b(s) = 0 \). If the condition is satisfied the algorithm terminates. If node \(\mathcal s \) still has excess supply then the alorithm goes to the next step. </p>
							<p> In this step the algorithm also builds the residual network on which the fuhrther steps are going to be performed. </p>
							
							</div>
							
							<div id = "fr-explanation-find-shortestpath">
								<h3> Find shortest path </h3>
								<p> The algorithm determines the shortest distances <math><mi>d</mi><mo stretchy="false">(</mo><mi>s</mi><mo>,</mo><mi>v</mi><mo stretchy="false">)</mo></math> from the excess node <math><mi>s</mi></math> to every node <math><mi>v</mi><mo>&#x2208;<!--∈--></mo><mi>V</mi></math> in the residual network <math><msub><mi>G</mi><mi>f</mi></msub></math> with respect to the reduced costs <math>
								  <msubsup>
									<mi>c</mi>
									<mrow class="MJX-TeXAtom-ORD">
									  <mi>v</mi>
									  <mo>,</mo>
									  <mi>w</mi>
									</mrow>
									<mrow class="MJX-TeXAtom-ORD">
									  <msup>
										<mi>p</mi>
										<mo>&#x2032;</mo>
									  </msup>
									</mrow>
								  </msubsup>
								</math>. By finding all shortest distances \(\mathcal d(v,s) \)  the algorithm also finds the shortest path \(\mathcal P \) from \(\mathcal s \) to \(\mathcal t \).
								</p>
								
								
							</div>
							<div id = "fr-explanation-update-potentials">
								<h3> Update potentials </h3>
								<p>At the begining of the algorithm the potentials for all nodes are set to 0. Then at every iteration the potentials <math><mi>p</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></math> for every node \(\mathcal v&isin;V \) are updated with respect to the old potentials and the calculated distances <math><mi>d</mi><mo stretchy="false">(</mo><mi>s</mi><mo>,</mo><mi>v</mi><mo stretchy="false">)</mo></math>.
								</p>
								<p>The potentisals are updated as follows:
								  <math display="block">
								  <msup>
									<mi>p</mi>
									<mo>&#x2032;</mo>
								  </msup>
								  <mo stretchy="false">(</mo>
								  <mi>v</mi>
								  <mo stretchy="false">)</mo>
								  <mo>=</mo>
								  <mi>p</mi>
								  <mo stretchy="false">(</mo>
								  <mi>v</mi>
								  <mo stretchy="false">)</mo>
								  <mo>&#x2212;<!-- − --></mo>
								  <mi>d</mi>
								  <mo stretchy="false">(</mo>
								  <mi>s</mi>
								  <mo>,</mo>
								  <mi>v</mi>
								  <mo stretchy="false">)</mo>
								</math>
								</p>
							</div>
							<div id = "fr-explanation-update-cost">
								<h3> Reduce the cost </h3>
								<p>
								Now with the updated potentials the algorithm is able to calculate the reduced costs <math>	   <msubsup>
									<mi>c</mi>
									<mrow class="MJX-TeXAtom-ORD">
									  <mi>v</mi>
									  <mo>,</mo>
									  <mi>w</mi>
									</mrow>
									<mrow class="MJX-TeXAtom-ORD">
									  <msup>
										<mi>p</mi>
										<mo>&#x2032;</mo>
									  </msup>
									</mrow>
								  </msubsup></math>. 
								The updated costs are calculated with the following formula:
								<math display="block">
								   <msubsup>
									<mi>c</mi>
									<mrow class="MJX-TeXAtom-ORD">
									  <mi>v</mi>
									  <mo>,</mo>
									  <mi>w</mi>
									</mrow>
									<mrow class="MJX-TeXAtom-ORD">
									  <msup>
										<mi>p</mi>
										<mo>&#x2032;</mo>
									  </msup>
									</mrow>
								  </msubsup>
								  <mo>=</mo>
								  <msub>
									<mi>c</mi>
									<mrow class="MJX-TeXAtom-ORD">
									  <mi>v</mi>
									  <mo>,</mo>
									  <mi>w</mi>
									</mrow>
								  </msub>
								  <mo>&#x2212;<!-- − --></mo>
								    <msup>
									<mi>p</mi>
									<mo>&#x2032;</mo>
									</msup>
								  <mo stretchy="false">(</mo>
								  <mi>v</mi>
								  <mo stretchy="false">)</mo>
								  <mo>+</mo>
								   <msup>
									<mi>p</mi>
									<mo>&#x2032;</mo>
									</msup>
								  <mo stretchy="false">(</mo>
								  <mi>w</mi>
								  <mo stretchy="false">)</mo>
								</math>
								</p>
								<p>The reduced cost <math>
								  <msubsup>
									<mi>c</mi>
									<mrow class="MJX-TeXAtom-ORD">
									  <mi>v</mi>
									  <mo>,</mo>
									  <mi>w</mi>
									</mrow>
									<mrow class="MJX-TeXAtom-ORD">
									  <msup>
										<mi>p</mi>
										<mo>&#x2032;</mo>
									  </msup>
									</mrow>
								  </msubsup>
								</math> for each edge <math xmlns="http://www.w3.org/1998/Math/MathML">
								  <mo stretchy="false">(</mo>
								  <mi>v</mi>
								  <mo>,</mo>
								  <mi>w</mi>
								  <mo stretchy="false">)</mo>
								  <mo>&#x2208;<!-- ∈ --></mo>
								  <mi>E</mi>
								</math> in a shortest path from node <math><mi>s</mi></math> to every other node is zero. 
								</p>
							</div>
							<div id = "fr-explanation-apply-augmentation-path">
								<h3> Augment flow through the shortest path </h3>
								<p>In this step the algorithm calculates the maximal amount of flow that can be augmentet through the shortest path <math><mi>P</mi></math>. If this capacity exceeds the demand of node <math><mi>t</mi></math> then the algorithm augments <math><mi>b</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></math> units of flow along the shortest path. 
								</p>
								<p>We calculate the amount of flow that is to be augmentet with the following formula:
								<math display="block">
								  <mi>&#x03B4;<!-- δ --></mi>
								  <mo>=</mo>
								  <mi>m</mi>
								  <mi>i</mi>
								  <mi>n</mi>
								  <mo fence="false" stretchy="false">{</mo>
								  <mi>b</mi>
								  <mo stretchy="false">(</mo>
								  <mi>s</mi>
								  <mo stretchy="false">)</mo>
								  <mo>,</mo>
								  <mo>&#x2212;<!-- − --></mo>
								  <mi>b</mi>
								  <mo stretchy="false">(</mo>
								  <mi>t</mi>
								  <mo stretchy="false">)</mo>
								  <mo>,</mo>
								  <mi>m</mi>
								  <mi>i</mi>
								  <mi>n</mi>
								  <mo fence="false" stretchy="false">{</mo>
								  <mi>r</mi>
								  <mo stretchy="false">(</mo>
								  <mi>v</mi>
								  <mo>,</mo>
								  <mi>w</mi>
								  <mo stretchy="false">)</mo>
								  <mo>:</mo>
								  <mo stretchy="false">(</mo>
								  <mi>v</mi>
								  <mo>,</mo>
								  <mi>w</mi>
								  <mo stretchy="false">)</mo>
								  <mo>&#x2208;<!-- ∈ --></mo>
								  <mi>P</mi>
								  <mo fence="false" stretchy="false">}</mo>
								  <mo fence="false" stretchy="false">}</mo>
								</math>
								</p>
								<p> And <math><mi>&#x03B4;<!-- δ --></mi></math> units of flow are augmentet along the shortest path <math><mi>P</mi></math>.
								</p>
							</div>
							
							<div id = "fr-explanation-finished">
								<h3> Finished </h3>
								The algorithm terminated. The excess of node <math><mi>s</mi></math> is zero and there are no more excess or demand nodes, therefore a feasible flow has been found.</p>
							</div>
                        </div>
					<!-- Tab Pseudocode-->
                        <div class="PseudocodeWrapper" id="tf1_div_statusPseudocode">
							<div id="fr-pseudocode-select-source">
                                <p>s &larr; pick(v)</p>
                            </div>
                            <div id="fr-pseudocode-select-target">
                                <p>t &larr; pick(v)</p>
                            </div>
                            <div id="fr-pseudocode-start-algorithm">
                                <p><strong>BEGIN</strong></p>
								<p>| (*Initialize max flow *)</p>
								<p>| Set: b(s) = max flow, b(t) = - max flow, </p>
								<p>|       b(v) = 0 for all v&isin;V\{s,t} </p>
								<p>|       p(v) = 0 for all v&isin;V </p>
                            </div>
							<div id="fr-pseudocode-main-loop">
                                <p>| (* Main loop *)</p>
								<p>| <strong> WHILE</strong> (b(s)>0)<strong> DO</strong></p>
								<p>| | Build the residual network with</p> 
								<p>| | respect to the current flow </p>
								<p>| |</p>
							</div>
							<div id="fr-pseudocode-find-shortestpath">
								<p>| | (* Find shortest path *)</p>
								<p>| | Execute BELLMAN-FORD ALGORITHM to</p>
								<p>| | find:</p>
								<p>| | 1.Shortest distances d(s,v), &forall;v&isin;V in <math><msub><mi>G</mi><mi>f</mi></msub></math></p> 
								<p>| | 2.The shortest path P from <strong>s</strong> to <strong>t</strong></p>
								<p>| |</p>
							</div>
							<div id="fr-pseudocode-update-potentials">
								<p>| | (* Update potentials *)</p>
								<p>| | <strong>FOR ALL</strong> v&isin;V <strong>DO</strong>  </p>
								<p>| |     p(v) := p(v) - d(s,v)</p>
								<p>| |</p>
							</div>
							<div id="pseudocode-update-cost">
								<p>| | (* Reduce cost *)</p>
								<p>| | <strong>FOR ALL</strong> (v,w)&isin;E <strong>DO</strong>  </p>
								<p>| |     <math><msubsup><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><mi>v</mi><mo>,</mo> <mi>w</mi></mrow><mi>p</mi></msubsup></math> := <math><msub><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><mi>v</mi><mo>,</mo>  <mi>w</mi></mrow></msub></math> - p(v) + p(w)</p>
								<p>| |</p>
							</div>
							<div id="fr-pseudocode-apply-augmentation-path">
								<p>| | (* Apply path *)</p>
								<p>| | <math><mi>&#x03B4;<!-- δ --></mi>
								  <mo>=</mo>
								  <mi>m</mi>
								  <mi>i</mi>
								  <mi>n</mi>
								  <mo fence="false" stretchy="false">{</mo>
								  <mi>b</mi>
								  <mo stretchy="false">(</mo>
								  <mi>s</mi>
								  <mo stretchy="false">)</mo>
								  <mo>,</mo>
								  <mo>&#x2212;<!-- − --></mo>
								  <mi>b</mi>
								  <mo stretchy="false">(</mo>
								  <mi>t</mi>
								  <mo stretchy="false">)</mo>
								  <mo>,</mo>
								  <mi>m</mi>
								  <mi>i</mi>
								  <mi>n</mi>
								  <mo fence="false" stretchy="false">{</mo>
								  <mi>r</mi>
								  <mo stretchy="false">(</mo>
								  <mi>v</mi>
								  <mo>,</mo>
								  <mi>w</mi>
								  <mo stretchy="false">)</mo>
								  <mo>:</mo>
								  <mo stretchy="false">(</mo>
								  <mi>v</mi>
								  <mo>,</mo>
								  <mi>w</mi>
								  <mo stretchy="false">)</mo>
								  <mo>&#x2208;<!-- ∈ --></mo>
								  <mi>P</mi>
								  <mo fence="false" stretchy="false">}</mo>
								  <mo fence="false" stretchy="false">}</mo>
								</math> </p>
								<p>| | Augment &delta; units of flow along the</p> 
								<p>| | path P</p>
							</div>
							<div id="fr-pseudocode-finished">
								<p>| <strong>END WHILE</strong></p>
								<p><strong>END</strong></p>
                            </div>
                        </div>
					</div>
                </div>
            </div>
             <!-- </div>-->
            <div id="tf1_div_TabIntroDialog" title="Exercise 1" class="tabIntroDialog">
                <h2>In this part you can test your knowledge: What would the algorithm do?</h2>
                <p>
                    The algorithm will be executed normally, but will stop in a few places. Then you will have to predict, what the algorithm would do next.
                </p>
                <p>Hint: Recall the description of the algorithm.</p>
            </div>
            <div id="tf1_div_confirmTabChange" title="Terminate the algorithm?" class="tabChangeWarningDialog">
                <h2>If you switch tabs, the execution will be terminated.</h2>
                <p>You can open <a href="#" target="_blank" tabindex="-1">another browser window</a> to read the description in parallel.</p>
				
				
				</div>
			</div>
			
			<div id="tab_tf2">
				<div>
					<!--  Graph auf linker Seite -->
				<div class="canvasWrapper">
					<div class="svgContainer">
						<svg class="graphCanvas" id="tf2_canvas_graph" width="700" height="450"></svg>
					</div>

					<a class="svgDownloader" download="graph-ex2.svg" href="data:text/plain,test">Download Graph</a>


	<!--Graph informationen: Graph anzeigen-->
					<div id="f2-graph-info">
						<span id="f2-graph-state"> </span>
					</div>

					<div id="f2-graph-flow">
						<span id="f2-flow-st"> </span>
					</div>

    <!-- Legende maximized-->
					<div class="Legende">
						<h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>

						<div class="LegendeText">
							<table>
								<tr>
									<td class="LegendeTabelle"><img src="img/node.svg" alt="node" class="LegendeIcon"></td>
									<td><span>node</span></td>
								</tr>
								<tr>
									<td class="LegendeTabelle"><img src="img/node-st.svg" alt="node" class="LegendeIcon"></td>
									<td><span>source/target node</span></td>
								</tr>
								<tr>
									<td class="LegendeTabelle"><img src="img/node-excess.svg" alt="node" class="LegendeIcon"></td>
									<td><span>excess node</span></td>
								</tr>
								<tr>
									<td class="LegendeTabelle"><img src="img/node-demand.svg" alt="node" class="LegendeIcon"></td>
									<td><span>demand node</span></td>
								</tr>
								<tr>
									<td class="LegendeTabelle"><img src="img/edge-flow.svg" alt="edge" class="LegendeIcon"></td>
									<td><span>edge with capacity 10, flow 7 and cost 1</span></td>
								</tr>
								<tr>
									<td class="LegendeTabelle"><img src="img/edge-residual.svg" alt="edge" class="LegendeIcon"></td>
									<td><span>edge in residual network</span></td>
								</tr>
								<tr>
									<td class="LegendeTabelle"><img src="img/edge-sp.svg" alt="edge" class="LegendeIcon"></td>
									<td><span>edge in shortest path</span></td>
								</tr>
							</table>
						</div>
					</div>

       <!-- Legende minimized -->
					<div class="LegendeMinimized">
						<h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
					</div>


				</div>

    <!-- rechter Teil -->
				<div id="tf2_div_statusWindow" class="statusWindow">
					<h2 class="">Fill out the missing values in the network!</h2>
	
				<div id="tf2_div_abspielbuttons">
           <!--  <input  id="tf2_button_rewind" type="checkbox"><label for="tf2_button_rewind" id="tf2_button_text_rewind">rewind</label> -->

					<button id="tf2_button_1Schritt">Next </button>
            <!--  <input  id="tf2_button_vorspulen" type="checkbox"><label for="tf2_button_vorspulen" id="tf2_button_text_fastforward">Zur nächsten Frage vorspulen</label> -->

            <!--  <span id="tf2_button_text_pause" style="display:none">Pause</span> -->
				</div>

				<div id="tf2_div_questionModal" class="ui-widget ui-widget-content ui-corner-all" style="display: none;">
				</div>

				<div id="tf2_div_statusTabs">
					<ul>
						<li><a href="#tf2_div_statusErklaerung">Explanation</a></li>
						<li><a href="#tf2_div_statusPseudocode">Pseudocode</a></li> 
					</ul>

				<div id="tf2_div_statusErklaerung">
					<div id="fr2-explanation-begin-algorithm">
						<h3> Fill out the missing fields. </h3>
						<p>In the following exercise you will get a random network \(N\) with the respective capacities and costs \(u(e)\) and \(c(e)\) for all edges \(e \in E\) as well as all potentials \(p(v)\) and balance functions \(b(v)\) for all nodes \(v&isin;V\).</p>
						<p> Your task is to fill the missing reduced costs <math><msubsup><mi>c</mi><mrow class="MJX-TeXAtom-ORD"> <mi>v</mi><mo>,</mo><mi>w</mi></mrow> <mi>p</mi></msubsup></math> and potentials \(\mathcal p(v) \) while running the algorithm.</p>
						<p> When you are ready to start with the excercise, click the button and then select a source node \(s\). </p>
					</div>
				<div id = "fr2-explanation-select-source">
					<h3> First choose a source node.</h3>
					<p> Please click on a node in the network to select it as the source/starting node <math xmlns="http://www.w3.org/1998/Math/MathML">
						<mstyle mathvariant="bold">
						  <mi>s</mi>
						</mstyle>
					  </math>. The flow is going to start from this node. It will have no incoming flow, but it will have outgoing flow (with the magnitude of the maximal feasible flow in the network) which makes it an excess node.
				</div>
				<div id = "fr2-explanation-select-target">
					<h3> Then choose a target node.</h3>
					<p> Please click on a node in the network to select it as the sink/target node <math xmlns="http://www.w3.org/1998/Math/MathML">
						<mstyle mathvariant="bold">
						  <mi>t</mi>
						</mstyle>
					  </math>. The flow ends in this node. It will have no outgoing flow, but it will still have incoming flow (with the magnitude of the maximal feasible flow in the network) which makes it a demand node.
				</div>
				 <div id="fr2-explanation-start-algorithm">
					<h3>Successive Shortest Path algorithm</h3>
					<p>Now the algorithm can begin. The maximal feasible flow in this graph is calculated with the help of the <a href = "https://www-m9.ma.tum.de/graph-algorithms/flow-ford-fulkerson/index_en.html"> Ford-Fulkerson algorithm</a>. The calculated flow is then set as an excess on the source node and as a demand on the target node: \(b(s) = max\ flow\) and \(b(t) = - max\ flow\).</p>
					<p>	Please click on <strong>next</strong> to start the algorithm.</p>
				</div>
				<div id = "fr2-explanation-main-loop"> 
					<h3> Entering the main loop </h3>
				<p>
				In the main loop the algorithm repeatedly tests for normalization with the condition \(\mathcal b(s) = 0 \). If the condition is satisfied the algorithm terminates. If node \(\mathcal s \) still has excess supply then the alorithm goes to the next step. </p>
				<p> In this step the algorithm also builds the residual network on which the fuhrther steps are going to be performed. </p>
				
				</div>
				
				<div id = "fr2-explanation-find-shortestpath">
					<h3> Find shortest path </h3>
					<p> The algorithm determines the shortest distances <math><mi>d</mi><mo stretchy="false">(</mo><mi>s</mi><mo>,</mo><mi>v</mi><mo stretchy="false">)</mo></math> from the excess node <math><mi>s</mi></math> to every node <math><mi>v</mi><mo>&#x2208;<!--∈--></mo><mi>V</mi></math> in the residual network <math><msub><mi>G</mi><mi>f</mi></msub></math> with respect to the reduced costs <math>
					  <msubsup>
						<mi>c</mi>
						<mrow class="MJX-TeXAtom-ORD">
						  <mi>v</mi>
						  <mo>,</mo>
						  <mi>w</mi>
						</mrow>
						<mrow class="MJX-TeXAtom-ORD">
						  <msup>
							<mi>p</mi>
							<mo>&#x2032;</mo>
						  </msup>
						</mrow>
					  </msubsup>
					</math>. By finding all shortest distances \(\mathcal d(v,s) \)  the algorithm also finds the shortest path \(\mathcal P \) from \(\mathcal s \) to \(\mathcal t \).
					</p>
					
					
				</div>
				
				<div id = "fr2-explanation-prepare-potentials">
					<h3> Update potentials </h3>
					<p>At the begining of the algorithm the potentials for all nodes are set to 0. Then at every iteration the potentials <math><mi>p</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></math> for every node \(\mathcal v&isin;V \) are updated with respect to the old potentials and the calculated distances <math><mi>d</mi><mo stretchy="false">(</mo><mi>s</mi><mo>,</mo><mi>v</mi><mo stretchy="false">)</mo></math>.
					</p>
					<p>The potentisals are updated as follows:
					  <math display="block">
					  <msup>
						<mi>p</mi>
						<mo>&#x2032;</mo>
					  </msup>
					  <mo stretchy="false">(</mo>
					  <mi>v</mi>
					  <mo stretchy="false">)</mo>
					  <mo>=</mo>
					  <mi>p</mi>
					  <mo stretchy="false">(</mo>
					  <mi>v</mi>
					  <mo stretchy="false">)</mo>
					  <mo>&#x2212;<!-- − --></mo>
					  <mi>d</mi>
					  <mo stretchy="false">(</mo>
					  <mi>s</mi>
					  <mo>,</mo>
					  <mi>v</mi>
					  <mo stretchy="false">)</mo>
					</math>
					</p>
				
				</div>
				
				<div id = "fr2-explanation-update-potentials">
					<h3> Update potentials </h3>
					<p>At the begining of the algorithm the potentials for all nodes are set to 0. Then at every iteration the potentials <math><mi>p</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></math> for every node \(\mathcal v&isin;V \) are updated with respect to the old potentials and the calculated distances <math><mi>d</mi><mo stretchy="false">(</mo><mi>s</mi><mo>,</mo><mi>v</mi><mo stretchy="false">)</mo></math>.
					</p>
					<p>The potentisals are updated as follows:
					  <math display="block">
					  <msup>
						<mi>p</mi>
						<mo>&#x2032;</mo>
					  </msup>
					  <mo stretchy="false">(</mo>
					  <mi>v</mi>
					  <mo stretchy="false">)</mo>
					  <mo>=</mo>
					  <mi>p</mi>
					  <mo stretchy="false">(</mo>
					  <mi>v</mi>
					  <mo stretchy="false">)</mo>
					  <mo>&#x2212;<!-- − --></mo>
					  <mi>d</mi>
					  <mo stretchy="false">(</mo>
					  <mi>s</mi>
					  <mo>,</mo>
					  <mi>v</mi>
					  <mo stretchy="false">)</mo>
					</math>
					</p>
				</div>
				
				<div id ="fr2-explanation-prepare-cost">
				<h3> Reduce the cost </h3>
					<p>
					Now with the updated potentials the algorithm is able to calculate the reduced costs <math>	   <msubsup>
						<mi>c</mi>
						<mrow class="MJX-TeXAtom-ORD">
						  <mi>v</mi>
						  <mo>,</mo>
						  <mi>w</mi>
						</mrow>
						<mrow class="MJX-TeXAtom-ORD">
						  <msup>
							<mi>p</mi>
							<mo>&#x2032;</mo>
						  </msup>
						</mrow>
					  </msubsup></math>. 
					The updated costs are calculated with the following formula:
					<math display="block">
					   <msubsup>
						<mi>c</mi>
						<mrow class="MJX-TeXAtom-ORD">
						  <mi>v</mi>
						  <mo>,</mo>
						  <mi>w</mi>
						</mrow>
						<mrow class="MJX-TeXAtom-ORD">
						  <msup>
							<mi>p</mi>
							<mo>&#x2032;</mo>
						  </msup>
						</mrow>
					  </msubsup>
					  <mo>=</mo>
					  <msub>
						<mi>c</mi>
						<mrow class="MJX-TeXAtom-ORD">
						  <mi>v</mi>
						  <mo>,</mo>
						  <mi>w</mi>
						</mrow>
					  </msub>
					  <mo>&#x2212;<!-- − --></mo>
						<msup>
						<mi>p</mi>
						<mo>&#x2032;</mo>
						</msup>
					  <mo stretchy="false">(</mo>
					  <mi>v</mi>
					  <mo stretchy="false">)</mo>
					  <mo>+</mo>
					   <msup>
						<mi>p</mi>
						<mo>&#x2032;</mo>
						</msup>
					  <mo stretchy="false">(</mo>
					  <mi>w</mi>
					  <mo stretchy="false">)</mo>
					</math>
					</p>
					<p>The reduced cost <math>
					  <msubsup>
						<mi>c</mi>
						<mrow class="MJX-TeXAtom-ORD">
						  <mi>v</mi>
						  <mo>,</mo>
						  <mi>w</mi>
						</mrow>
						<mrow class="MJX-TeXAtom-ORD">
						  <msup>
							<mi>p</mi>
							<mo>&#x2032;</mo>
						  </msup>
						</mrow>
					  </msubsup>
					</math> for each edge <math xmlns="http://www.w3.org/1998/Math/MathML">
					  <mo stretchy="false">(</mo>
					  <mi>v</mi>
					  <mo>,</mo>
					  <mi>w</mi>
					  <mo stretchy="false">)</mo>
					  <mo>&#x2208;<!-- ∈ --></mo>
					  <mi>E</mi>
					</math> in a shortest path from node <math><mi>s</mi></math> to every other node is zero. 
					</p>
				
				</div>
				<div id = "fr2-explanation-update-cost">
					<h3> Reduce the cost </h3>
					<p>
					Now with the updated potentials the algorithm is able to calculate the reduced costs <math>	   <msubsup>
						<mi>c</mi>
						<mrow class="MJX-TeXAtom-ORD">
						  <mi>v</mi>
						  <mo>,</mo>
						  <mi>w</mi>
						</mrow>
						<mrow class="MJX-TeXAtom-ORD">
						  <msup>
							<mi>p</mi>
							<mo>&#x2032;</mo>
						  </msup>
						</mrow>
					  </msubsup></math>. 
					The updated costs are calculated with the following formula:
					<math display="block">
					   <msubsup>
						<mi>c</mi>
						<mrow class="MJX-TeXAtom-ORD">
						  <mi>v</mi>
						  <mo>,</mo>
						  <mi>w</mi>
						</mrow>
						<mrow class="MJX-TeXAtom-ORD">
						  <msup>
							<mi>p</mi>
							<mo>&#x2032;</mo>
						  </msup>
						</mrow>
					  </msubsup>
					  <mo>=</mo>
					  <msub>
						<mi>c</mi>
						<mrow class="MJX-TeXAtom-ORD">
						  <mi>v</mi>
						  <mo>,</mo>
						  <mi>w</mi>
						</mrow>
					  </msub>
					  <mo>&#x2212;<!-- − --></mo>
						<msup>
						<mi>p</mi>
						<mo>&#x2032;</mo>
						</msup>
					  <mo stretchy="false">(</mo>
					  <mi>v</mi>
					  <mo stretchy="false">)</mo>
					  <mo>+</mo>
					   <msup>
						<mi>p</mi>
						<mo>&#x2032;</mo>
						</msup>
					  <mo stretchy="false">(</mo>
					  <mi>w</mi>
					  <mo stretchy="false">)</mo>
					</math>
					</p>
					<p>The reduced cost <math>
					  <msubsup>
						<mi>c</mi>
						<mrow class="MJX-TeXAtom-ORD">
						  <mi>v</mi>
						  <mo>,</mo>
						  <mi>w</mi>
						</mrow>
						<mrow class="MJX-TeXAtom-ORD">
						  <msup>
							<mi>p</mi>
							<mo>&#x2032;</mo>
						  </msup>
						</mrow>
					  </msubsup>
					</math> for each edge <math xmlns="http://www.w3.org/1998/Math/MathML">
					  <mo stretchy="false">(</mo>
					  <mi>v</mi>
					  <mo>,</mo>
					  <mi>w</mi>
					  <mo stretchy="false">)</mo>
					  <mo>&#x2208;<!-- ∈ --></mo>
					  <mi>E</mi>
					</math> in a shortest path from node <math><mi>s</mi></math> to every other node is zero. 
					</p>
				</div>
				<div id = "fr2-explanation-apply-augmentation-path">
					<h3> Augment flow through the shortest path </h3>
					<p>In this step the algorithm calculates the maximal amount of flow that can be augmentet through the shortest path <math><mi>P</mi></math>. If this capacity exceeds the demand of node <math><mi>t</mi></math> then the algorithm augments <math><mi>b</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></math> units of flow along the shortest path. 
					</p>
					<p>We calculate the amount of flow that is to be augmentet with the following formula:
					<math display="block">
					  <mi>&#x03B4;<!-- δ --></mi>
					  <mo>=</mo>
					  <mi>m</mi>
					  <mi>i</mi>
					  <mi>n</mi>
					  <mo fence="false" stretchy="false">{</mo>
					  <mi>b</mi>
					  <mo stretchy="false">(</mo>
					  <mi>s</mi>
					  <mo stretchy="false">)</mo>
					  <mo>,</mo>
					  <mo>&#x2212;<!-- − --></mo>
					  <mi>b</mi>
					  <mo stretchy="false">(</mo>
					  <mi>t</mi>
					  <mo stretchy="false">)</mo>
					  <mo>,</mo>
					  <mi>m</mi>
					  <mi>i</mi>
					  <mi>n</mi>
					  <mo fence="false" stretchy="false">{</mo>
					  <mi>r</mi>
					  <mo stretchy="false">(</mo>
					  <mi>v</mi>
					  <mo>,</mo>
					  <mi>w</mi>
					  <mo stretchy="false">)</mo>
					  <mo>:</mo>
					  <mo stretchy="false">(</mo>
					  <mi>v</mi>
					  <mo>,</mo>
					  <mi>w</mi>
					  <mo stretchy="false">)</mo>
					  <mo>&#x2208;<!-- ∈ --></mo>
					  <mi>P</mi>
					  <mo fence="false" stretchy="false">}</mo>
					  <mo fence="false" stretchy="false">}</mo>
					</math>
					</p>
					<p> And <math><mi>&#x03B4;<!-- δ --></mi></math> units of flow are augmentet along the shortest path <math><mi>P</mi></math>.
					</p>
				</div>
				
				<div id = "fr2-explanation-finished">
					<h3> Finished </h3>
					The algorithm terminated. The excess of node <math><mi>s</mi></math> is zero and there are no more excess or demand nodes, therefore a feasible flow has been found.</p>
				</div>
             
              <p> </p>

              <button id="tf2_button_start">Click here to start!</button> </center>
                <!-- <img id="tf2_img_1" src="img/Bes/ex01.svg" alt="Suche" width="250"/> -->

            </div>




            <!-- Tab Pseudocode -->
            <div class="PseudocodeWrapper" id="tf2_div_statusPseudocode">
				<div id="fr2-pseudocode-select-source">
					<p class = "pseudocode">s &larr; pick(v)</p>
				</div>
				<div id="fr2-pseudocode-select-target">
					<p class = "pseudocode">t &larr; pick(v)</p>
				</div>
				<div id="fr2-pseudocode-start-algorithm">
					<p class = "pseudocode"><strong>BEGIN</strong></p>
					<p class = "pseudocode">| (*Initialize max flow *)</p>
					<p class = "pseudocode">| Set: b(s) = max flow, b(t) = - max flow, </p>
					<p class = "pseudocode">|       b(v) = 0 for all v&isin;V\{s,t} </p>
					<p class = "pseudocode">|       p(v) = 0 for all v&isin;V </p>
				</div>
				<div id="fr2-pseudocode-main-loop">
					<p class = "pseudocode">| (* Main loop *)</p>
					<p class = "pseudocode">| <strong> WHILE</strong> (b(s)>0)<strong> DO</strong></p>
					<p class = "pseudocode">| | Build the residual network with</p> 
					<p class = "pseudocode">| | respect to the current flow </p>
					<p class = "pseudocode">| |</p>
				</div>
				<div id="fr2-pseudocode-find-shortestpath">
					<p class = "pseudocode">| | (* Find shortest path *)</p>
					<p class = "pseudocode">| | Execute BELLMAN-FORD ALGORITHM to</p>
					<p class = "pseudocode">| | find:</p>
					<p class = "pseudocode">| | 1.Shortest distances d(s,v), &forall;v&isin;V in <math><msub><mi>G</mi><mi>f</mi></msub></math></p> 
					<p class = "pseudocode">| | 2.The shortest path P from <strong>s</strong> to <strong>t</strong></p>
					<p class = "pseudocode">| |</p>
				</div>
				<div id="fr2-pseudocode-update-potentials">
					<p class = "pseudocode">| | (* Update potentials *)</p>
					<p class = "pseudocode">| | <strong>FOR ALL</strong> v&isin;V <strong>DO</strong>  </p>
					<p class = "pseudocode">| |     p(v) := p(v) - d(s,v)</p>
					<p class = "pseudocode">| |</p>
				</div>
				<div id="fr2-pseudocode-update-cost">
					<p class = "pseudocode">| | (* Reduce cost *)</p>
					<p class = "pseudocode">| | <strong>FOR ALL</strong> (v,w)&isin;E <strong>DO</strong>  </p>
					<p class = "pseudocode">| |     <math><msubsup><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><mi>v</mi><mo>,</mo> <mi>w</mi></mrow><mi>p</mi></msubsup></math> := <math><msub><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><mi>v</mi><mo>,</mo>  <mi>w</mi></mrow></msub></math> - p(v) + p(w)</p>
					<p class = "pseudocode">| |</p>
				</div>
				<div id="fr2-pseudocode-apply-augmentation-path">
					<p class = "pseudocode">| | (* Apply path *)</p>
					<p class = "pseudocode">| | <math><mi>&#x03B4;<!-- δ --></mi>
					  <mo>=</mo>
					  <mi>m</mi>
					  <mi>i</mi>
					  <mi>n</mi>
					  <mo fence="false" stretchy="false">{</mo>
					  <mi>b</mi>
					  <mo stretchy="false">(</mo>
					  <mi>s</mi>
					  <mo stretchy="false">)</mo>
					  <mo>,</mo>
					  <mo>&#x2212;<!-- − --></mo>
					  <mi>b</mi>
					  <mo stretchy="false">(</mo>
					  <mi>t</mi>
					  <mo stretchy="false">)</mo>
					  <mo>,</mo>
					  <mi>m</mi>
					  <mi>i</mi>
					  <mi>n</mi>
					  <mo fence="false" stretchy="false">{</mo>
					  <mi>r</mi>
					  <mo stretchy="false">(</mo>
					  <mi>v</mi>
					  <mo>,</mo>
					  <mi>w</mi>
					  <mo stretchy="false">)</mo>
					  <mo>:</mo>
					  <mo stretchy="false">(</mo>
					  <mi>v</mi>
					  <mo>,</mo>
					  <mi>w</mi>
					  <mo stretchy="false">)</mo>
					  <mo>&#x2208;<!-- ∈ --></mo>
					  <mi>P</mi>
					  <mo fence="false" stretchy="false">}</mo>
					  <mo fence="false" stretchy="false">}</mo>
					</math> </p>
					<p class = "pseudocode">| | Augment &delta; units of flow along the</p> 
					<p class = "pseudocode">| | path P</p>
				</div>
				<div id="fr2-pseudocode-finished">
					<p class = "pseudocode">| <strong>END WHILE</strong></p>
					<p class = "pseudocode"><strong>END</strong></p>
				</div>
            </div>



			</div>
		</div>
	</div>

  <div id="tf2_div_TabIntroDialog" title="Exercise 2" class="tabIntroDialog">

                <h2>In this part you can test your understanding of the algorithm!</h2>
                <p>
                    You will get a random network . Your task is to fill out the missing reduced costs, balances and potentials that occur during the algorithm execution!
                </p>
				
                <p><strong>Tip:</strong> Before you start read the information on residual networks again.</p>
				<p><strong> WARNING! </p></strong>
				<p> You can set the missing values only once. When a value is set it cannot be changed any more. </p>
                <p>Good Luck!</p>
            </div>
            <div id="tf2_div_confirmTabChange" title="Aufgabe abbrechen?" class="tabChangeWarningDialog">

				<h2>If you switch tabs, the execution will be terminated.</h2>
                <p>You can open <a href="#" target="_blank" tabindex="-1">another browser window</a> to read another tab in parallel.</p>
				</div>
			</div>
			
		
			
			<div id="tab_tw" style="display: none;">
            <div id="tw_Accordion">
                <h3>What is the pseudocode of the algorithm?</h3>
                <div>
                    <pre><code><strong>INPUT:</strong> Directed graph G=(V,E), capacity function u(e), cost function c(e), a source node s
and a target node t
<strong>OUTPUT:</strong> minimum-cost max-flow f(e) for the graph G=(V,E)</code></pre>
                      <hr>
                      <pre>
<code><strong>BEGIN</strong>
    (* Initialize max flow *)
    f_val = CALCULATE THE VALUE OF MAX FLOW();
    b(s) = f<sub>val</sub>;
    b(t) = - f_<sub>val</sub>;
    b(v) = 0 &forall;v&isin;V\{s,t};
    p(v) = 0 &forall;v&isin;V;
    (* Main Loop *)
    <strong>WHILE</strong> b(s) > 0 <strong>DO</strong>
        CONSTRUCT THE RESIDUAL GRAPH G<sub>f</sub> WITH RESPECT TO THE CURRENT FLOW; 
	(* Find shortest path *)
	EXECUTE BELLMAN-FORD ON G<sub>f</sub> TO FIND:
	(1) Shortest distances <strong>d(s,v)</strong> from <strong>s</strong> to every other node v&isin;V;
	(2) The shortest path <strong>P</strong> from <strong>s</strong> to <strong>t</strong>;
	(* Update potentials *)
	<strong>FOR ALL</strong> v&isin;V<strong>DO</strong>  
	    p(v) := p(v) - d(s,v);
	(* Reduce costs *)
	<strong>FOR ALL</strong> (v,w)&isin;E<strong>DO</strong> 
	    c<sup>p</sup><sub>v,w</sub> := c<sub>v,w</sub> - p(v) + p(w); 
	(* Apply path *)
	&delta; = min{b(s), -b(t), min{r(v,w):(v,w)&isin;P}};
        AUGMENT <strong>&delta;</strong> UNITS OF FLOW ALONG THE SHORTEST PATH <strong>P</strong>;
    <strong>END WHILE</strong>	
<strong>END</strong>
 </code></pre>
                </div>

                <h3>How efficient is the algorithm?</h3>
                <div>
                    <p>The algorithm runs as long as there is any imbalanced node. In our implementation we only have one source \(\mathcal s \) and one sink node \(\mathcal t \), consequently the algorithm will run until the nodes \(\mathcal s \) and \(\mathcal t \) are balanced. At each iteration the algorithm solves a shortest path problem with nonnegative edge lengths (costs) and strictli decreases the excess of node \(\mathcal s \) and the demand of node \(\mathcal t \). Therefore, if \(\mathcal U\) is the upper bound for the largest supply of the excess node, then the algorithm will terminate in at maximal \(\mathcal U \) iterations. Let the runtime for fnding a shortest path with nonnegtive edge costs be \(\mathcal S(|V|,|E|,C)\), with \(\mathcal C\) being the total cost of the initial flow . The exact value of \(\mathcal S(|V|, |E|, C)\) depends on the algorithm that is chosen for solving the shortest path problem and because we are looking for the shortest path in the residual network G<sub>f</sub> and there the costs are bounded by \(\mathcal|V|*C\), the time needed for solving the shortest path problem will be \(\mathcal S(|V|, |E|, |V|*C)\). So the algorithm has overall complexity of \(\mathcal O(U*S(|V|,|E|,|V|*C))\) which is pseudopolynomial.</p>
					<p>The algorithm has polynomial complexity for the assignment problem, which is the special case where \(\mathcal U=1\). With some scaling techniques it is possible to develope a strongly polynomial time version of the successive-shortest-path algorithm. 
					</p>
                </div>

                <h3>References</h3>
                <div>
                  <h4>Literature</h4>
                    <dl>
					 <dt>[AR93]</dt><dd> Ravindra K. Ahuja, Thomas L. Magnanti, and James B. Orlin (1993). "Network Flows: Theory, Algorithms, and Applications". Prentice-Hall, Inc., Upper Saddle River, NJ, USA. ISBN:<a href="http://dl.acm.org/citation.cfm?id=137406">0-13-617549-X </a>.</dd>
                    </dl>

                    <h4>Web resources</h4>
                  <ol>
                      <li><a href="https://en.wikipedia.org/wiki/Minimum-cost_flow_problem">Wikipedia: Minimum-cost flow problem</a></li>
                  </ol>
                </div>

                <h3>Where can I find more information about graph algorithms?</h3>
                <div><p>Other graph algorithms are explained on the <a href="http://www-m9.ma.tum.de/Allgemeines/Routenplanung">Website of Chair M9</a> of the TU München.</p>
				<p>Furthermore there is an interesting book about network flows: "Network Flows: Theory, Algorithms, and Applications"
                  <p><a href="http://www.ma.tum.de/Studium/StudieninteressierteEn">Studying mathematics at the TU München</a> answers all questions about graph theory (if an answer is known).</p>
                </div>
                <h3>A last remark about this page's goal and citations</h3>
				         <div><p>Chair M9 of Technische Universität München does research in the fields of discrete mathematics, applied geometry and the optimization of mathematical problems. The algorithms presented on the pages at hand are very basic examples for methods of discrete mathematics (the research conducted daily at the chair reaches far beyond that point). This page shall provide the possibility pupils and students to (better) understand and fully comprehend the algorithms ,which are of importance also in daily life. Therefore, the presentation concentrates on the algorithms' ideas, and often explains them with just minimal or no mathematical notation at all.</p>
						 <p>Please be advised that the pages presented here have been created within the scope of student theses, supervised by Chair M9. The code and corresponding presentation could only be tested selectively, which is why we cannot guarantee the complete correctness of the pages and the implemented algorithms.</p>
            				<p>To cite this page, please use the following information:</p>
            				<ul>
            				<li>Title: Successive-Shortest-Path Algorithm</li>
            				<li>Authors: Gergana Kratuncheva, Wolfgang F. Riedl; Technische Universität München</li>
            				<li>Link: <a href=""> </a></li>
            				</ul>
            		</div>

            </div>
        </div>
    </div>
			
			

	
	
	
	
	
	<!-- End tabs -->
	</div>
	
	
	 <footer>
        <p class="Disclaimer">
            Bachelor thesis Project of Gergana Kratuncheva at Chair M9 of Technische Universität München. 2017 | <a href="index_de.html">DE</a> | <a href="http://www-m9.ma.tum.de/Allgemeines/Rechtliches">Terms of use</a> | <a href="http://www-m9.ma.tum.de/Allgemeines/Impressum">About Us</a> | <a href="mailto&#58;m&#46;ritter&#64;ma&#46;tum&#46;de&#63;subject&#61;M9&#45;Web&#45;Feedback">Suggestions</a>
        </p>
    </footer>
</body>

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	